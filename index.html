<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motorcycle Fuel Tracker</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Fuel Tracker">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIk1vdG9yY3ljbGUgRnVlbCBUcmFja2VyIiwKICAic2hvcnRfbmFtZSI6ICJGdWVsVHJhY2tlciIsCiAgImRlc2NyaXB0aW9uIjogIkdQUy1iYXNlZCBmdWVsIGNvbnN1bXB0aW9uIHRyYWNrZXIgZm9yIG1vdG9yY3ljbGVzIiwKICAic3RhcnRfdXJsIjogIi8iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiM2NjdlZWEiLAogICJ0aGVtZV9jb2xvciI6ICIjNjY3ZWVhIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M00zUXViM0puTHpJd01EQXZjM1puSWlCM2FXUjBhRDBpTVRJNElpQm9aV2xuYUhROUlqRXlPQ0krUEhKbFkzUWdkMmxrZEdnOUlqRXlPQ0lnYUdWcFoyaDBQU0l4TWpnaUlHWnBiR3c5SWljMk5qZGxaV0VpSUhKNFBTSTNJaTA4TDNKbFkzUStQSFJsZUhRZ2VEMGlOalFpSUhrOUlqVXdJaUJtYVd4c1BTSWpabVptSWlCdVlYWnBZV0Z3Y0MxaGJtTm9iM0k5SW0xcFpHUnNaU0lnZEhWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJZ1ptOXVkQzF6YVhwbFBTSXlOQ0lnWm05dWRDMTNaV2xuYUhROUltSnZiR1FpUGp3dmRHVjRkRDQ4TDNOMlp6ND0iLAogICAgICAic2l6ZXMiOiAiMTI4eDEyOCIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXSwKICAib3JpZW50YXRpb24iOiAicG9ydHJhaXQiLAogICJjYXRlZ29yaWVzIjogWyJ1dGlsaXRpZXMiLCAidHJhbnNwb3J0Il0KfQ==">
    
    <!-- App Icons (using data URIs for simplicity) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4Ij48cmVjdCB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgZmlsbD0iIzY2N2VlYSIgcng9IjciLz48dGV4dCB4PSI2NCIgeT0iNTAiIGZpbGw9IiNmZmYiIG5hdmlnYXRwcC1hbmNob3I9Im1pZGRsZSIgdHVuZS1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIyNCIgZm9udC13ZWlnaHQ9ImJvbGQiPjwvdGV4dD48L3N2Zz4=">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4Ij48cmVjdCB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgZmlsbD0iIzY2N2VlYSIgcng9IjciLz48dGV4dCB4PSI2NCIgeT0iNTAiIGZpbGw9IiNmZmYiIG5hdmlnYXRwcC1hbmNob3I9Im1pZGRsZSIgdHVuZS1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIyNCIgZm9udC13ZWlnaHQ9ImJvbGQiPjwvdGV4dD48L3N2Zz4=">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            user-select: none; /* Prevent text selection for app-like feel */
            -webkit-touch-callout: none; /* Disable callout on iOS */
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 30px 0;
            justify-content: center;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            touch-action: manipulation; /* Better touch handling */
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .gps-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-value {
            font-size: 1.4em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .calibration {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .calibration h3 {
            margin-top: 0;
            text-align: center;
        }
        
        .cal-points {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        input[type="number"] {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
        }
        
        input[type="number"]::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* PWA Install Banner */
        .install-banner {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .install-banner button {
            background: #667eea;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            margin-left: 10px;
        }
        
        /* Responsive improvements for mobile */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 20px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
            
            .metric-value {
                font-size: 2em;
            }
            
            .controls {
                gap: 10px;
            }
            
            button {
                padding: 10px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèçÔ∏è Motorcycle Fuel Tracker</h1>
        
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">Current Speed</div>
                <div class="metric-value" id="currentSpeed">0</div>
                <div class="metric-label">MPH</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Engine RPM</div>
                <div class="metric-value" id="currentRPM">--</div>
                <div class="metric-label">RPM</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Estimated MPG</div>
                <div class="metric-value" id="currentMPG">--</div>
                <div class="metric-label">Miles/Gallon</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Fuel Used</div>
                <div class="metric-value" id="fuelUsed">0.00</div>
                <div class="metric-label">Gallons</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Fuel Remaining</div>
                <div class="metric-value" id="fuelRemaining">4.50</div>
                <div class="metric-label">Gallons</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Estimated Range</div>
                <div class="metric-value" id="estimatedRange">--</div>
                <div class="metric-label">Miles</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Trip Distance</div>
                <div class="metric-value" id="tripDistance">0.0</div>
                <div class="metric-label">Miles</div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" onclick="startTracking()">Start Tracking</button>
            <button id="stopBtn" onclick="stopTracking()" disabled>Stop Tracking</button>
            <button id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
            <button onclick="resetTrip()">Reset Trip</button>
            <button onclick="refillTank()">Refill Tank</button>
        </div>
        
        <div class="status" id="status">
            GPS tracking not started. Click "Start Tracking" to begin.
        </div>
        
        <div class="calibration">
            <h3>üìä Calibration Points</h3>
            <div class="cal-points">
                <div>
                    <label>Highway Speed (mph): </label>
                    <input type="number" id="highwaySpeed" value="60" min="30" max="100">
                    <label> ‚Üí MPG: </label>
                    <input type="number" id="highwayMPG" value="45" min="20" max="80">
                </div>
                <div>
                    <label>Local Speed (mph): </label>
                    <input type="number" id="localSpeed" value="30" min="10" max="60">
                    <label> ‚Üí MPG: </label>
                    <input type="number" id="localMPG" value="35" min="15" max="60">
                </div>
                <div>
                    <label>Idle Consumption (gal/hr): </label>
                    <input type="number" id="idleConsumption" value="0.2" min="0.1" max="0.5" step="0.1">
                </div>
            </div>
            
            <h4 style="margin: 20px 0 10px 0; text-align: center;">üîß Engine Configuration</h4>
            <div class="cal-points">
                <div>
                    <label>Cylinders: </label>
                    <select id="engineCylinders">
                        <option value="1">Single (1)</option>
                        <option value="2" selected>Twin (2)</option>
                        <option value="3">Triple (3)</option>
                        <option value="4">Four (4)</option>
                    </select>
                </div>
                <div>
                    <label>Idle RPM: </label>
                    <input type="number" id="idleRPM" value="1200" min="600" max="2000" step="50">
                </div>
                <div>
                    <label>Redline RPM: </label>
                    <input type="number" id="redlineRPM" value="8000" min="6000" max="15000" step="100">
                </div>
                <div>
                    <label>Enable RPM Detection: </label>
                    <input type="checkbox" id="enableRPM" checked>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px;">
                <button onclick="updateCalibration()">Update Calibration</button>
            </div>
        </div>
        
        <!-- Microphone Test Section -->
        <div class="calibration">
            <h3>üé§ Microphone Test (RPM Detection)</h3>
            <p style="font-size: 0.9em; opacity: 0.8; margin-bottom: 15px;">
                Test microphone access for future RPM-based fuel calculations
            </p>
            
            <div class="controls">
                <button id="micTestBtn" onclick="testMicrophone()">Start Microphone Test</button>
                <button id="micStopBtn" onclick="stopMicrophone()" disabled>Stop Test</button>
            </div>
            
            <div class="status" id="micStatus">
                Click "Start Microphone Test" to check iOS PWA compatibility
            </div>
            
            <div class="gps-info" id="audioInfo" style="display: none;">
                <div class="info-item">
                    <div class="metric-label">Audio Level</div>
                    <div class="info-value" id="audioLevel">0</div>
                    <div class="metric-label">dB</div>
                </div>
                <div class="info-item">
                    <div class="metric-label">Dominant Freq</div>
                    <div class="info-value" id="dominantFreq">0</div>
                    <div class="metric-label">Hz</div>
                </div>
            </div>
            
            <div class="metric-card" id="testResults" style="display: none; margin-top: 15px;">
                <div class="metric-label">Test Results</div>
                <div id="testSummary" style="font-size: 0.9em; line-height: 1.4;"></div>
            </div>
        </div>
    </div>

    <!-- Version Footer -->
    <div style="text-align: center; padding: 20px; opacity: 0.7; font-size: 0.8em; color: white;">
        v2.0.0 ‚Ä¢ RPM Edition
    </div>

    <!-- PWA Install Banner -->
    <div class="install-banner" id="installBanner">
        üì± Install this app on your phone for better experience!
        <button onclick="installApp()">Install</button>
        <button onclick="hideInstallBanner()">Later</button>
    </div>

    <script>
        // PWA Installation
        let deferredPrompt;
        let isInstalled = false;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            showInstallBanner();
        });
        
        window.addEventListener('appinstalled', () => {
            isInstalled = true;
            hideInstallBanner();
        });
        
        function showInstallBanner() {
            if (!isInstalled && !localStorage.getItem('installBannerDismissed')) {
                document.getElementById('installBanner').style.display = 'block';
            }
        }
        
        function hideInstallBanner() {
            document.getElementById('installBanner').style.display = 'none';
            localStorage.setItem('installBannerDismissed', 'true');
        }
        
        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        console.log('User accepted the install prompt');
                    }
                    deferredPrompt = null;
                    hideInstallBanner();
                });
            }
        }
        
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Register inline service worker
                const swCode = `
                    const CACHE_NAME = 'fuel-tracker-v1';
                    const urlsToCache = [
                        '/',
                        '/offline.html'
                    ];
                    
                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then((cache) => {
                                    return cache.addAll(urlsToCache);
                                })
                        );
                    });
                    
                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request)
                                .then((response) => {
                                    return response || fetch(event.request);
                                })
                        );
                    });
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then((registration) => {
                        console.log('SW registered: ', registration);
                    })
                    .catch((registrationError) => {
                        console.log('SW registration failed: ', registrationError);
                    });
            });
        }
        
        // Prevent zoom on double tap (iOS)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // State variables
        let isTracking = false;
        let isPaused = false;
        let watchId = null;
        let lastPosition = null;
        let lastTime = null;
        let fuelUsed = 0;
        let tripDistance = 0;
        let tankCapacity = 4.5;
        
        // RPM Detection variables
        let rpmAudioContext = null;
        let rpmAudioStream = null;
        let rpmAnalyser = null;
        let rpmDataArray = null;
        let rpmAnimationId = null;
        let currentRPM = 0;
        let rpmEnabled = true;
        
        // Load saved data
        window.addEventListener('load', () => {
            loadSavedData();
        });
        
        // Save data when page unloads
        window.addEventListener('beforeunload', () => {
            saveData();
        });
        
        function saveData() {
            const data = {
                fuelUsed,
                tripDistance,
                tankCapacity,
                calibration,
                timestamp: Date.now()
            };
            localStorage.setItem('fuelTrackerData', JSON.stringify(data));
        }
        
        function loadSavedData() {
            const saved = localStorage.getItem('fuelTrackerData');
            if (saved) {
                const data = JSON.parse(saved);
                fuelUsed = data.fuelUsed || 0;
                tripDistance = data.tripDistance || 0;
                tankCapacity = data.tankCapacity || 4.5;
                calibration = data.calibration || calibration;
                
                // Update displays
                document.getElementById('fuelUsed').textContent = fuelUsed.toFixed(3);
                document.getElementById('tripDistance').textContent = tripDistance.toFixed(1);
                updateRemainingFuel();
                
                // Update calibration inputs
                document.getElementById('highwaySpeed').value = calibration.highway.speed;
                document.getElementById('highwayMPG').value = calibration.highway.mpg;
                document.getElementById('localSpeed').value = calibration.local.speed;
                document.getElementById('localMPG').value = calibration.local.mpg;
                document.getElementById('idleConsumption').value = calibration.idle.gallonsPerHour;
                
                // Update engine configuration inputs
                document.getElementById('engineCylinders').value = calibration.engine.cylinders;
                document.getElementById('idleRPM').value = calibration.engine.idleRPM;
                document.getElementById('redlineRPM').value = calibration.engine.redlineRPM;
                document.getElementById('enableRPM').checked = calibration.engine.enableRPM;
                
                // Initialize RPM state
                rpmEnabled = calibration.engine.enableRPM;
            }
        }
        
        // Calibration points
        let calibration = {
            highway: {speed: 60, mpg: 45},
            local: {speed: 30, mpg: 35},
            idle: {gallonsPerHour: 0.2}, // Typical motorcycle idle consumption
            engine: {
                cylinders: 2,
                idleRPM: 1200,
                redlineRPM: 8000,
                enableRPM: true
            }
        };
        
        function interpolateMPG(speed) {
            const {highway, local} = calibration;
            
            // Handle edge cases
            if (speed <= 0) return local.mpg; // Idling/stopped
            if (speed <= local.speed) {
                // Linear interpolation from 0 to local speed
                const ratio = speed / local.speed;
                return local.mpg * ratio + local.mpg * (1 - ratio) * 0.7; // Assume 70% efficiency at idle
            }
            if (speed >= highway.speed) {
                // Extrapolate beyond highway speed (efficiency typically decreases)
                const speedRatio = speed / highway.speed;
                return highway.mpg / Math.pow(speedRatio, 0.5); // Square root decay
            }
            
            // Linear interpolation between local and highway
            const ratio = (speed - local.speed) / (highway.speed - local.speed);
            return local.mpg + (highway.mpg - local.mpg) * ratio;
        }
        
        function calculateFuelConsumption(speed, timeMinutes, rpm = null) {
            if (timeMinutes <= 0) return 0;
            
            // Handle idle consumption for very low speeds (< 5 mph)
            if (speed < 5) {
                return calibration.idle.gallonsPerHour * (timeMinutes / 60);
            }
            
            // Use advanced RPM-based calculation if available
            if (rpm && rpm > 0 && calibration.engine.enableRPM) {
                return calculateRPMBasedFuelConsumption(speed, rpm, timeMinutes);
            }
            
            // Fallback to speed-only calculation
            const mpg = interpolateMPG(speed);
            const milesTrailed = speed * (timeMinutes / 60);
            return milesTrailed / mpg;
        }
        
        function calculateRPMBasedFuelConsumption(speed, rpm, timeMinutes) {
            const {idleRPM, redlineRPM} = calibration.engine;
            const milesTrailed = speed * (timeMinutes / 60);
            
            // Calculate engine load factor based on RPM vs Speed relationship
            const expectedRPMForSpeed = calculateExpectedRPM(speed);
            const loadFactor = Math.max(0.3, Math.min(2.0, rpm / expectedRPMForSpeed));
            
            // Base MPG from speed interpolation
            const baseMPG = interpolateMPG(speed);
            
            // Apply RPM-based corrections
            const rpmFactor = calculateRPMEfficiencyFactor(rpm);
            const loadPenalty = Math.pow(loadFactor, 0.8); // Higher load = worse efficiency
            
            // Calculate final MPG with RPM considerations
            const finalMPG = baseMPG * rpmFactor / loadPenalty;
            
            return milesTrailed / Math.max(5, finalMPG); // Minimum 5 MPG sanity check
        }
        
        function calculateExpectedRPM(speed) {
            // Estimate expected RPM based on typical motorcycle gearing
            // This is a simplified model - real motorcycles vary significantly
            if (speed < 10) return calibration.engine.idleRPM;
            if (speed < 25) return calibration.engine.idleRPM + (speed - 10) * 100; // Low gears
            if (speed < 45) return 2500 + (speed - 25) * 75; // Mid gears
            return 4000 + (speed - 45) * 50; // High gears
        }
        
        function calculateRPMEfficiencyFactor(rpm) {
            const {idleRPM, redlineRPM} = calibration.engine;
            
            // Most efficient RPM range is typically 25-40% of redline
            const efficientRPMMin = redlineRPM * 0.25;
            const efficientRPMMax = redlineRPM * 0.40;
            
            if (rpm < idleRPM) return 0.4; // Very inefficient below idle
            if (rpm >= idleRPM && rpm < efficientRPMMin) {
                // Gradually improve from idle to efficient range
                return 0.7 + 0.3 * (rpm - idleRPM) / (efficientRPMMin - idleRPM);
            }
            if (rpm >= efficientRPMMin && rpm <= efficientRPMMax) {
                return 1.0; // Peak efficiency
            }
            if (rpm > efficientRPMMax) {
                // Efficiency degrades after peak range
                const overRevFactor = Math.min(1.0, (redlineRPM - rpm) / (redlineRPM - efficientRPMMax));
                return 0.6 + 0.4 * overRevFactor;
            }
            
            return 0.5; // Default fallback
        }
        
        function startTracking() {
            if (!navigator.geolocation) {
                document.getElementById('status').textContent = 'GPS not supported by this browser.';
                return;
            }
            
            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 1000
            };
            
            watchId = navigator.geolocation.watchPosition(
                handlePositionUpdate,
                handlePositionError,
                options
            );
            
            isTracking = true;
            isPaused = false;
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            document.getElementById('pauseBtn').disabled = false;
            document.getElementById('status').textContent = 'GPS tracking started. Waiting for position data...';
            
            // Keep screen on (where supported)
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => {});
            }
            
            // Start RPM detection if enabled
            if (rpmEnabled && calibration.engine.enableRPM) {
                startRPMDetection();
            }
        }
        
        function stopTracking() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            isTracking = false;
            isPaused = false;
            lastPosition = null;
            lastTime = null;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('status').textContent = 'GPS tracking stopped.';
            document.getElementById('currentSpeed').textContent = '0';
            document.getElementById('currentMPG').textContent = '--';
            
            // Stop RPM detection
            stopRPMDetection();
            
            saveData();
        }
        
        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                pauseBtn.textContent = 'Resume';
                document.getElementById('status').textContent = 'Tracking paused - fuel consumption stopped.';
            } else {
                pauseBtn.textContent = 'Pause';
                document.getElementById('status').textContent = 'Tracking resumed - fuel consumption active.';
            }
        }
        
        function handlePositionUpdate(position) {
            const currentTime = Date.now();
            const currentPosition = {
                lat: position.coords.latitude,
                lon: position.coords.longitude,
                accuracy: position.coords.accuracy
            };
            
            document.getElementById('status').textContent = 
                `GPS active. Accuracy: ¬±${Math.round(position.coords.accuracy)}m`;
            
            if (lastPosition && lastTime) {
                const timeDelta = (currentTime - lastTime) / 1000 / 60; // minutes
                
                if (timeDelta > 0.1) { // Update every 6 seconds minimum
                    const distance = calculateDistance(lastPosition, currentPosition);
                    const speed = (distance / timeDelta) * 60; // mph
                    
                    // Filter out unrealistic speeds (GPS noise)
                    if (speed <= 150 && position.coords.accuracy <= 50) {
                        updateMetrics(speed, timeDelta, distance);
                    }
                    
                    lastTime = currentTime;
                    lastPosition = currentPosition;
                }
            } else {
                // First position
                lastTime = currentTime;
                lastPosition = currentPosition;
            }
        }
        
        function handlePositionError(error) {
            let message = 'GPS error: ';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message += 'Location access denied by user.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += 'Location information unavailable.';
                    break;
                case error.TIMEOUT:
                    message += 'Location request timed out.';
                    break;
                default:
                    message += 'Unknown error occurred.';
                    break;
            }
            document.getElementById('status').textContent = message;
        }
        
        function calculateDistance(pos1, pos2) {
            // Haversine formula for distance in miles
            const R = 3959; // Earth's radius in miles
            const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const dLon = (pos2.lon - pos1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function updateMetrics(speed, timeMinutes, distance) {
            // Update current readings
            document.getElementById('currentSpeed').textContent = Math.round(speed);
            
            // Calculate MPG considering RPM if available
            let currentMPG;
            if (currentRPM > 0 && calibration.engine.enableRPM) {
                // Use RPM-aware MPG calculation
                const baseMPG = interpolateMPG(speed);
                const rpmFactor = calculateRPMEfficiencyFactor(currentRPM);
                const expectedRPM = calculateExpectedRPM(speed);
                const loadFactor = Math.max(0.3, Math.min(2.0, currentRPM / expectedRPM));
                const loadPenalty = Math.pow(loadFactor, 0.8);
                currentMPG = baseMPG * rpmFactor / loadPenalty;
            } else {
                currentMPG = interpolateMPG(speed);
            }
            
            document.getElementById('currentMPG').textContent = currentMPG.toFixed(1);
            
            // Only calculate fuel consumption and distance if not paused
            if (!isPaused) {
                const fuelConsumed = calculateFuelConsumption(speed, timeMinutes, currentRPM);
                fuelUsed += fuelConsumed;
                tripDistance += distance;
            }
            
            // Update displays
            document.getElementById('fuelUsed').textContent = fuelUsed.toFixed(3);
            
            const fuelRemaining = Math.max(0, tankCapacity - fuelUsed);
            document.getElementById('fuelRemaining').textContent = fuelRemaining.toFixed(2);
            
            // Estimate range based on current MPG
            const estimatedRange = fuelRemaining * currentMPG;
            document.getElementById('estimatedRange').textContent = 
                estimatedRange > 0 ? Math.round(estimatedRange) : '0';
            
            document.getElementById('tripDistance').textContent = tripDistance.toFixed(1);
        }
        
        function resetTrip() {
            fuelUsed = 0;
            tripDistance = 0;
            document.getElementById('fuelUsed').textContent = '0.000';
            document.getElementById('tripDistance').textContent = '0.0';
            updateRemainingFuel();
            saveData();
        }
        
        function refillTank() {
            fuelUsed = 0;
            updateRemainingFuel();
            saveData();
        }
        
        function updateRemainingFuel() {
            const fuelRemaining = Math.max(0, tankCapacity - fuelUsed);
            document.getElementById('fuelRemaining').textContent = fuelRemaining.toFixed(2);
        }
        
        function updateCalibration() {
            calibration.highway.speed = parseInt(document.getElementById('highwaySpeed').value);
            calibration.highway.mpg = parseInt(document.getElementById('highwayMPG').value);
            calibration.local.speed = parseInt(document.getElementById('localSpeed').value);
            calibration.local.mpg = parseInt(document.getElementById('localMPG').value);
            calibration.idle.gallonsPerHour = parseFloat(document.getElementById('idleConsumption').value);
            
            // Update engine configuration
            calibration.engine.cylinders = parseInt(document.getElementById('engineCylinders').value);
            calibration.engine.idleRPM = parseInt(document.getElementById('idleRPM').value);
            calibration.engine.redlineRPM = parseInt(document.getElementById('redlineRPM').value);
            calibration.engine.enableRPM = document.getElementById('enableRPM').checked;
            rpmEnabled = calibration.engine.enableRPM;
            
            // Update current MPG display if tracking
            if (isTracking) {
                const currentSpeed = parseInt(document.getElementById('currentSpeed').textContent);
                const currentMPG = interpolateMPG(currentSpeed);
                document.getElementById('currentMPG').textContent = currentMPG.toFixed(1);
            }
            
            saveData();
        }
        
        // Microphone Test Functionality
        let audioContext = null;
        let audioStream = null;
        let analyser = null;
        let dataArray = null;
        let animationId = null;
        let testResults = {
            getUserMediaSupported: false,
            permissionGranted: false,
            audioContextWorking: false,
            fftAnalysisWorking: false,
            standaloneMode: false
        };
        
        function testMicrophone() {
            document.getElementById('micTestBtn').disabled = true;
            document.getElementById('micStopBtn').disabled = false;
            document.getElementById('micStatus').textContent = 'Testing microphone access...';
            document.getElementById('audioInfo').style.display = 'none';
            document.getElementById('testResults').style.display = 'none';
            
            // Check if running in standalone PWA mode
            testResults.standaloneMode = window.matchMedia('(display-mode: standalone)').matches;
            
            startMicrophoneTest();
        }
        
        async function startMicrophoneTest() {
            try {
                // Test 1: Check getUserMedia support
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('getUserMedia not supported');
                }
                testResults.getUserMediaSupported = true;
                document.getElementById('micStatus').textContent = 'getUserMedia supported ‚úì Requesting permission...';
                
                // Test 2: Request microphone permission
                audioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                testResults.permissionGranted = true;
                document.getElementById('micStatus').textContent = 'Microphone permission granted ‚úì Testing Web Audio API...';
                
                // Test 3: Create AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = audioContext.createMediaStreamSource(audioStream);
                testResults.audioContextWorking = true;
                document.getElementById('micStatus').textContent = 'Web Audio API working ‚úì Testing FFT analysis...';
                
                // Test 4: Set up FFT analysis
                analyser = audioContext.createAnalyser();
                analyser.fftSize = 2048;
                const bufferLength = analyser.frequencyBinCount;
                dataArray = new Uint8Array(bufferLength);
                
                source.connect(analyser);
                testResults.fftAnalysisWorking = true;
                
                document.getElementById('micStatus').textContent = 'All tests passed ‚úì Analyzing audio...';
                document.getElementById('audioInfo').style.display = 'grid';
                
                // Start real-time analysis
                analyzeAudio();
                
            } catch (error) {
                document.getElementById('micStatus').textContent = `‚ùå Error: ${error.message}`;
                showTestResults();
            }
        }
        
        function analyzeAudio() {
            if (!analyser) return;
            
            analyser.getByteFrequencyData(dataArray);
            
            // Calculate audio level (RMS)
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i] * dataArray[i];
            }
            const rms = Math.sqrt(sum / dataArray.length);
            const decibels = Math.round(20 * Math.log10(rms / 255) + 100); // Convert to approximate dB
            
            // Find dominant frequency
            let maxValue = 0;
            let maxIndex = 0;
            for (let i = 1; i < dataArray.length; i++) { // Skip DC component
                if (dataArray[i] > maxValue) {
                    maxValue = dataArray[i];
                    maxIndex = i;
                }
            }
            const dominantFreq = Math.round(maxIndex * audioContext.sampleRate / analyser.fftSize);
            
            // Update display
            document.getElementById('audioLevel').textContent = decibels;
            document.getElementById('dominantFreq').textContent = dominantFreq;
            
            animationId = requestAnimationFrame(analyzeAudio);
        }
        
        function stopMicrophone() {
            if (animationId) {
                cancelAnimationFrame(animationId);
                animationId = null;
            }
            
            if (audioStream) {
                audioStream.getTracks().forEach(track => track.stop());
                audioStream = null;
            }
            
            if (audioContext) {
                audioContext.close();
                audioContext = null;
            }
            
            analyser = null;
            dataArray = null;
            
            document.getElementById('micTestBtn').disabled = false;
            document.getElementById('micStopBtn').disabled = true;
            document.getElementById('audioInfo').style.display = 'none';
            
            showTestResults();
        }
        
        function showTestResults() {
            const results = testResults;
            let summary = `
                <strong>Compatibility Test Results:</strong><br>
                getUserMedia Support: ${results.getUserMediaSupported ? '‚úì Yes' : '‚ùå No'}<br>
                Microphone Permission: ${results.permissionGranted ? '‚úì Granted' : '‚ùå Denied'}<br>
                Web Audio API: ${results.audioContextWorking ? '‚úì Working' : '‚ùå Failed'}<br>
                FFT Analysis: ${results.fftAnalysisWorking ? '‚úì Working' : '‚ùå Failed'}<br>
                PWA Mode: ${results.standaloneMode ? 'Standalone' : 'Browser'}<br><br>
                <strong>RPM Detection Feasibility:</strong><br>
                ${results.permissionGranted && results.fftAnalysisWorking ? 
                  'üü¢ <strong>FEASIBLE</strong> - All tests passed!' : 
                  'üî¥ <strong>NOT FEASIBLE</strong> - Critical tests failed'}
            `;
            
            document.getElementById('testSummary').innerHTML = summary;
            document.getElementById('testResults').style.display = 'block';
            document.getElementById('micStatus').textContent = 'Test completed. See results below.';
        }
        
        // RPM Detection Functions
        async function startRPMDetection() {
            if (!rpmEnabled || !calibration.engine.enableRPM) return;
            
            try {
                // Request microphone access for RPM detection
                rpmAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 22050
                    }
                });
                
                // Create audio context for RPM analysis
                rpmAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = rpmAudioContext.createMediaStreamSource(rpmAudioStream);
                
                // Set up analyzer for RPM detection
                rpmAnalyser = rpmAudioContext.createAnalyser();
                rpmAnalyser.fftSize = 2048;
                rpmAnalyser.smoothingTimeConstant = 0.8; // Smooth RPM readings
                
                const bufferLength = rpmAnalyser.frequencyBinCount;
                rpmDataArray = new Uint8Array(bufferLength);
                
                source.connect(rpmAnalyser);
                
                // Start RPM analysis loop
                analyzeRPM();
                
            } catch (error) {
                console.log('RPM detection failed:', error.message);
                // Continue with GPS-only tracking
            }
        }
        
        function analyzeRPM() {
            if (!rpmAnalyser || !rpmEnabled) return;
            
            rpmAnalyser.getByteFrequencyData(rpmDataArray);
            
            const cylinders = calibration.engine.cylinders;
            const idleRPM = calibration.engine.idleRPM;
            const redlineRPM = calibration.engine.redlineRPM;
            
            // Calculate expected frequency ranges for this engine
            const minFreq = (idleRPM * cylinders) / 120; // Fundamental at idle
            const maxFreq = (redlineRPM * cylinders) / 60; // 2nd harmonic at redline
            
            // Convert frequency to FFT bin indices
            const sampleRate = rpmAudioContext.sampleRate;
            const binSize = sampleRate / rpmAnalyser.fftSize;
            const minBin = Math.max(1, Math.floor(minFreq / binSize));
            const maxBin = Math.min(rpmDataArray.length - 1, Math.floor(maxFreq / binSize));
            
            // Find multiple peaks in engine frequency range
            const peaks = [];
            
            // Find all significant peaks above threshold
            for (let i = minBin; i <= maxBin; i++) {
                if (rpmDataArray[i] > 80) { // Lower threshold for peak detection
                    // Check if this is a local maximum
                    const isLocalMax = (i === 0 || rpmDataArray[i] > rpmDataArray[i-1]) &&
                                      (i === rpmDataArray.length-1 || rpmDataArray[i] > rpmDataArray[i+1]);
                    
                    if (isLocalMax) {
                        const frequency = i * binSize;
                        peaks.push({ bin: i, amplitude: rpmDataArray[i], frequency });
                    }
                }
            }
            
            // Sort peaks by amplitude (strongest first)
            peaks.sort((a, b) => b.amplitude - a.amplitude);
            
            // Calculate RPM from detected peaks
            if (peaks.length > 0 && peaks[0].amplitude > 120) { // Higher threshold for valid signal
                let bestRPM = 0;
                let bestConfidence = 0;
                
                // Smart harmonic analysis - try multiple interpretations of each peak
                for (const peak of peaks.slice(0, 3)) { // Check top 3 peaks
                    const freq = peak.frequency;
                    
                    // Test different harmonic interpretations
                    const rpmCandidates = [
                        { rpm: (freq * 120) / cylinders, harmonic: 1, confidence: peak.amplitude * 0.8 }, // Fundamental
                        { rpm: (freq * 60) / cylinders, harmonic: 2, confidence: peak.amplitude * 1.2 },  // 2nd harmonic (often strongest)
                        { rpm: (freq * 40) / cylinders, harmonic: 3, confidence: peak.amplitude * 0.9 },  // 3rd harmonic
                        { rpm: (freq * 30) / cylinders, harmonic: 4, confidence: peak.amplitude * 0.7 }   // 4th harmonic
                    ];
                    
                    for (const candidate of rpmCandidates) {
                        // Check if RPM is within reasonable engine range
                        if (candidate.rpm >= idleRPM * 0.7 && candidate.rpm <= redlineRPM * 1.3) {
                            // Boost confidence for readings near expected idle
                            let adjustedConfidence = candidate.confidence;
                            if (candidate.rpm >= idleRPM * 0.8 && candidate.rpm <= idleRPM * 1.5) {
                                adjustedConfidence *= 1.5; // Favor idle range readings
                            }
                            
                            if (adjustedConfidence > bestConfidence) {
                                bestRPM = candidate.rpm;
                                bestConfidence = adjustedConfidence;
                            }
                        }
                    }
                }
                
                // Apply additional validation
                if (bestRPM > 0 && bestConfidence > 150) { // Require high confidence
                
                    // Apply stronger smoothing to prevent erratic readings
                    currentRPM = currentRPM * 0.85 + bestRPM * 0.15; // More conservative smoothing
                    document.getElementById('currentRPM').textContent = Math.round(currentRPM);
                } else {
                    // No confident reading - decay current RPM
                    if (currentRPM > idleRPM * 0.5) {
                        currentRPM = currentRPM * 0.92; // Gradual decay
                        document.getElementById('currentRPM').textContent = Math.round(currentRPM);
                    } else {
                        currentRPM = 0;
                        document.getElementById('currentRPM').textContent = '--';
                    }
                }
            } else {
                // No strong signal - possibly idle or engine off
                if (currentRPM > idleRPM * 0.5) {
                    currentRPM = currentRPM * 0.9; // Gradually decrease
                    document.getElementById('currentRPM').textContent = Math.round(currentRPM);
                } else {
                    document.getElementById('currentRPM').textContent = '--';
                    currentRPM = 0;
                }
            }
            
            // Update at 15 FPS instead of 60 FPS for better performance
            rpmAnimationId = setTimeout(analyzeRPM, 67); // 1000ms / 15fps ‚âà 67ms
        }
        
        function stopRPMDetection() {
            if (rpmAnimationId) {
                clearTimeout(rpmAnimationId);
                rpmAnimationId = null;
            }
            
            if (rpmAudioStream) {
                rpmAudioStream.getTracks().forEach(track => track.stop());
                rpmAudioStream = null;
            }
            
            if (rpmAudioContext) {
                rpmAudioContext.close();
                rpmAudioContext = null;
            }
            
            rpmAnalyser = null;
            rpmDataArray = null;
            currentRPM = 0;
            document.getElementById('currentRPM').textContent = '--';
        }
    </script>
</body>
</html>
