<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Motorcycle Fuel Tracker</title>
    
    <!-- PWA Meta Tags -->
    <meta name="theme-color" content="#667eea">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Fuel Tracker">
    <link rel="manifest" href="data:application/json;base64,ewogICJuYW1lIjogIk1vdG9yY3ljbGUgRnVlbCBUcmFja2VyIiwKICAic2hvcnRfbmFtZSI6ICJGdWVsVHJhY2tlciIsCiAgImRlc2NyaXB0aW9uIjogIkdQUy1iYXNlZCBmdWVsIGNvbnN1bXB0aW9uIHRyYWNrZXIgZm9yIG1vdG9yY3ljbGVzIiwKICAic3RhcnRfdXJsIjogIi8iLAogICJkaXNwbGF5IjogInN0YW5kYWxvbmUiLAogICJiYWNrZ3JvdW5kX2NvbG9yIjogIiM2NjdlZWEiLAogICJ0aGVtZV9jb2xvciI6ICIjNjY3ZWVhIiwKICAiaWNvbnMiOiBbCiAgICB7CiAgICAgICJzcmMiOiAiZGF0YTppbWFnZS9zdmcreG1sO2Jhc2U2NCxQSE4yWnlCNGJXeHVjejBpYUhSMGNEb3ZMM2QzZHk1M00zUXViM0puTHpJd01EQXZjM1puSWlCM2FXUjBhRDBpTVRJNElpQm9aV2xuYUhROUlqRXlPQ0krUEhKbFkzUWdkMmxrZEdnOUlqRXlPQ0lnYUdWcFoyaDBQU0l4TWpnaUlHWnBiR3c5SWljMk5qZGxaV0VpSUhKNFBTSTNJaTA4TDNKbFkzUStQSFJsZUhRZ2VEMGlOalFpSUhrOUlqVXdJaUJtYVd4c1BTSWpabVptSWlCdVlYWnBZV0Z3Y0MxaGJtTm9iM0k5SW0xcFpHUnNaU0lnZEhWNGRDMWhibU5vYjNJOUltMXBaR1JzWlNJZ1ptOXVkQzF6YVhwbFBTSXlOQ0lnWm05dWRDMTNaV2xuYUhROUltSnZiR1FpUGp3dmRHVjRkRDQ4TDNOMlp6ND0iLAogICAgICAic2l6ZXMiOiAiMTI4eDEyOCIsCiAgICAgICJ0eXBlIjogImltYWdlL3N2Zyt4bWwiCiAgICB9CiAgXSwKICAib3JpZW50YXRpb24iOiAicG9ydHJhaXQiLAogICJjYXRlZ29yaWVzIjogWyJ1dGlsaXRpZXMiLCAidHJhbnNwb3J0Il0KfQ==">
    
    <!-- App Icons (using data URIs for simplicity) -->
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4Ij48cmVjdCB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgZmlsbD0iIzY2N2VlYSIgcng9IjciLz48dGV4dCB4PSI2NCIgeT0iNTAiIGZpbGw9IiNmZmYiIG5hdmlnYXRwcC1hbmNob3I9Im1pZGRsZSIgdHVuZS1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIyNCIgZm9udC13ZWlnaHQ9ImJvbGQiPjwvdGV4dD48L3N2Zz4=">
    <link rel="apple-touch-icon" href="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIxMjgiIGhlaWdodD0iMTI4Ij48cmVjdCB3aWR0aD0iMTI4IiBoZWlnaHQ9IjEyOCIgZmlsbD0iIzY2N2VlYSIgcng9IjciLz48dGV4dCB4PSI2NCIgeT0iNTAiIGZpbGw9IiNmZmYiIG5hdmlnYXRwcC1hbmNob3I9Im1pZGRsZSIgdHVuZS1hbmNob3I9Im1pZGRsZSIgZm9udC1zaXplPSIyNCIgZm9udC13ZWlnaHQ9ImJvbGQiPjwvdGV4dD48L3N2Zz4=">
    
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 800px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            min-height: 100vh;
            user-select: none; /* Prevent text selection for app-like feel */
            -webkit-touch-callout: none; /* Disable callout on iOS */
        }
        
        .container {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.3);
        }
        
        h1 {
            text-align: center;
            margin-bottom: 30px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }
        
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin: 30px 0;
        }
        
        .metric-card {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 12px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 4px 16px rgba(0, 0, 0, 0.2);
        }
        
        .metric-value {
            font-size: 2.5em;
            font-weight: bold;
            margin: 10px 0;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.3);
        }
        
        .metric-label {
            font-size: 0.9em;
            opacity: 0.9;
            text-transform: uppercase;
            letter-spacing: 1px;
        }
        
        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 15px;
            margin: 30px 0;
            justify-content: center;
        }
        
        button {
            background: rgba(255, 255, 255, 0.2);
            border: 2px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 12px 24px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            font-weight: 600;
            transition: all 0.3s ease;
            backdrop-filter: blur(5px);
            touch-action: manipulation; /* Better touch handling */
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.3);
            border-color: rgba(255, 255, 255, 0.5);
            transform: translateY(-2px);
        }
        
        button:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none;
        }
        
        .status {
            text-align: center;
            padding: 15px;
            margin: 20px 0;
            border-radius: 8px;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        .gps-info {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
            padding: 20px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
        }
        
        .info-item {
            text-align: center;
        }
        
        .info-value {
            font-size: 1.4em;
            font-weight: bold;
            margin: 5px 0;
        }
        
        .calibration {
            background: rgba(255, 255, 255, 0.1);
            border-radius: 10px;
            padding: 20px;
            margin: 20px 0;
        }
        
        .calibration h3 {
            margin-top: 0;
            text-align: center;
        }
        
        .cal-points {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin: 15px 0;
        }
        
        input[type="number"] {
            background: rgba(255, 255, 255, 0.2);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 14px;
            width: 80px;
        }
        
        input[type="number"]::placeholder {
            color: rgba(255, 255, 255, 0.7);
        }
        
        /* PWA Install Banner */
        .install-banner {
            display: none;
            position: fixed;
            bottom: 20px;
            left: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.5);
            z-index: 1000;
        }
        
        .install-banner button {
            background: #667eea;
            border: none;
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            margin-left: 10px;
        }
        
        /* Responsive improvements for mobile */
        @media (max-width: 600px) {
            body {
                padding: 10px;
            }
            
            .container {
                padding: 20px;
            }
            
            .metrics-grid {
                grid-template-columns: 1fr 1fr;
                gap: 15px;
            }
            
            .metric-value {
                font-size: 2em;
            }
            
            .controls {
                gap: 10px;
            }
            
            button {
                padding: 10px 16px;
                font-size: 14px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèçÔ∏è Motorcycle Fuel Tracker</h1>
        
        <div class="metrics-grid">
            <div class="metric-card">
                <div class="metric-label">Current Speed</div>
                <div class="metric-value" id="currentSpeed">0</div>
                <div class="metric-label">MPH</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Engine RPM</div>
                <div class="metric-value">
                    <span id="currentRPM" style="color: #00ff00;">--</span>
                </div>
                <div class="metric-label">RPM</div>
            </div>
            
            <div class="metric-card" style="display: none;">
                <div class="metric-label">Estimated MPG</div>
                <div class="metric-value" id="currentMPG">--</div>
                <div class="metric-label">Miles/Gallon</div>
            </div>
            
            <div class="metric-card">
                <div class="metric-label">Fuel Analysis</div>
                <div class="metric-value" style="font-size: 0.7em; line-height: 1.1;">
                    <div style="font-size: 1.1em; font-weight: bold;">
                        <span id="fuelInjectionRate">--cc/stroke</span>
                    </div>
                    <div style="margin-top: 3px;">
                        Load: <span id="throttleLoad">--%</span><br>
                        AFR: <span id="estimatedAFR">--:1</span>
                    </div>
                    <div style="margin-top: 3px; font-size: 0.9em;">
                        Used: <span id="fuelUsed">0g 0oz</span><br>
                        Left: <span id="fuelRemaining">4g</span>
                    </div>
                </div>
            </div>
            
            <div class="metric-card" style="display: none;">
                <div class="metric-label">Estimated Range</div>
                <div class="metric-value" id="estimatedRange">--</div>
                <div class="metric-label">Miles</div>
            </div>
            
            <div class="metric-card" style="display: none;">
                <div class="metric-label">Trip Distance</div>
                <div class="metric-value" id="tripDistance">0.0</div>
                <div class="metric-label">Miles</div>
            </div>

            <div class="metric-card">
                <div class="metric-label">Roll Angle</div>
                <div class="metric-value" style="height: 120px; display: flex; align-items: center; justify-content: center;">
                    <svg id="rollHorizon" width="100" height="100" viewBox="-50 -50 100 100" style="background: linear-gradient(to bottom, #87CEEB 0%, #87CEEB 50%, #8B4513 50%, #8B4513 100%); border-radius: 50%; border: 2px solid rgba(255,255,255,0.3);">
                        <!-- Fixed aircraft symbol (center) -->
                        <g id="aircraftSymbol">
                            <!-- Main body -->
                            <line x1="-20" y1="0" x2="20" y2="0" stroke="yellow" stroke-width="3" stroke-linecap="round"/>
                            <!-- Wings -->
                            <line x1="-15" y1="-8" x2="-15" y2="8" stroke="yellow" stroke-width="2" stroke-linecap="round"/>
                            <line x1="15" y1="-8" x2="15" y2="8" stroke="yellow" stroke-width="2" stroke-linecap="round"/>
                            <!-- Center dot -->
                            <circle cx="0" cy="0" r="2" fill="yellow"/>
                        </g>

                        <!-- Rotating horizon line -->
                        <g id="horizonLine">
                            <line x1="-45" y1="0" x2="45" y2="0" stroke="white" stroke-width="2"/>
                            <!-- Horizon tick marks -->
                            <line x1="-35" y1="-3" x2="-35" y2="3" stroke="white" stroke-width="1"/>
                            <line x1="-25" y1="-2" x2="-25" y2="2" stroke="white" stroke-width="1"/>
                            <line x1="-15" y1="-3" x2="-15" y2="3" stroke="white" stroke-width="1"/>
                            <line x1="15" y1="-3" x2="15" y2="3" stroke="white" stroke-width="1"/>
                            <line x1="25" y1="-2" x2="25" y2="2" stroke="white" stroke-width="1"/>
                            <line x1="35" y1="-3" x2="35" y2="3" stroke="white" stroke-width="1"/>
                        </g>

                        <!-- Roll angle markings (fixed) -->
                        <g id="rollMarkings" stroke="white" stroke-width="1" fill="white" font-size="8" text-anchor="middle">
                            <!-- 30 degree marks -->
                            <line x1="-21.65" y1="-37.5" x2="-18.66" y2="-32.32" stroke-width="2"/>
                            <line x1="21.65" y1="-37.5" x2="18.66" y2="-32.32" stroke-width="2"/>
                            <!-- 45 degree marks -->
                            <line x1="-31.82" y1="-31.82" x2="-28.28" y2="-28.28"/>
                            <line x1="31.82" y1="-31.82" x2="28.28" y2="-28.28"/>
                            <!-- 60 degree marks -->
                            <line x1="-37.5" y1="-21.65" x2="-32.32" y2="-18.66" stroke-width="2"/>
                            <line x1="37.5" y1="-21.65" x2="32.32" y2="-18.66" stroke-width="2"/>
                        </g>
                    </svg>
                </div>
                <div class="metric-label">
                    <span id="lateralGForce">0.0</span>g
                    <div style="font-size: 0.7em; margin-top: 2px;">
                        <span id="turnIndicator" style="color: #888;">--</span>
                    </div>
                </div>
            </div>


            <div class="metric-card">
                <div class="metric-label">Remaining Daylight</div>
                <div class="metric-value" id="remainingDaylight">--:--</div>
                <div class="metric-label">Hours:Minutes</div>
            </div>

            <div class="metric-card">
                <div class="metric-label">Safe Turn Radius</div>
                <div class="metric-value" style="font-size: 0.8em; line-height: 1.2;">
                    <div id="safeRadius" style="font-size: 1.4em; font-weight: bold;">--</div>
                    <div style="font-size: 0.7em; margin-top: 5px;">
                        Zone: <span id="turnSafetyZone" style="color: #00ff00;">SAFE</span>
                    </div>
                    <div style="font-size: 0.6em; margin-top: 3px;">
                        Max: <span id="maxSafeSpeed">--</span> mph
                    </div>
                </div>
                <div class="metric-label">Feet @ Current Speed</div>
            </div>

            <div class="metric-card" style="display: none;">
                <div class="metric-label">3D Acceleration Vector</div>
                <div class="metric-value" style="height: 120px; display: flex; align-items: center; justify-content: center;">
                    <svg id="accelVector" width="100" height="100" viewBox="-50 -50 100 100" style="background: rgba(255,255,255,0.1); border-radius: 50%;">
                        <!-- 3D coordinate system with labels -->
                        <!-- X-axis (left-right) -->
                        <line x1="-40" y1="0" x2="40" y2="0" stroke="rgba(255,100,100,0.6)" stroke-width="2"/>
                        <text x="35" y="-5" fill="rgba(255,100,100,0.8)" font-size="10" font-weight="bold">X</text>

                        <!-- Y-axis (forward-back, adjusted for device orientation) -->
                        <line x1="0" y1="-40" x2="0" y2="40" stroke="rgba(100,255,100,0.6)" stroke-width="2"/>
                        <text x="5" y="-35" fill="rgba(100,255,100,0.8)" font-size="10" font-weight="bold">Y</text>

                        <!-- Z-axis representation (diagonal perspective) -->
                        <line x1="-20" y1="20" x2="20" y2="-20" stroke="rgba(100,100,255,0.6)" stroke-width="2"/>
                        <text x="15" y="-25" fill="rgba(100,100,255,0.8)" font-size="10" font-weight="bold">Z</text>

                        <!-- Center point -->
                        <circle cx="0" cy="0" r="3" fill="rgba(255,255,255,0.7)"/>

                        <!-- Main acceleration vector (simple line, no arrowhead) -->
                        <line id="accelArrow" x1="0" y1="0" x2="0" y2="0" stroke="#ffff00" stroke-width="3" stroke-linecap="round"/>

                        <!-- Component vectors -->
                        <line id="accelX" x1="0" y1="0" x2="0" y2="0" stroke="rgba(255,100,100,0.7)" stroke-width="2" stroke-dasharray="3,2" stroke-linecap="round"/>
                        <line id="accelY" x1="0" y1="0" x2="0" y2="0" stroke="rgba(100,255,100,0.7)" stroke-width="2" stroke-dasharray="3,2" stroke-linecap="round"/>
                        <line id="accelZ" x1="0" y1="0" x2="0" y2="0" stroke="rgba(100,100,255,0.7)" stroke-width="2" stroke-dasharray="3,2" stroke-linecap="round"/>
                    </svg>
                </div>
                <div class="metric-label">
                    <div style="font-size: 0.8em; line-height: 1.2;">
                        <div><span id="accelMagnitude">0.0</span> m/s¬≤ total</div>
                        <div style="color: rgba(255,100,100,0.9);">X: <span id="accelXValue">0.0</span></div>
                        <div style="color: rgba(100,255,100,0.9);">Y: <span id="accelYValue">0.0</span></div>
                        <div style="color: rgba(100,100,255,0.9);">Z: <span id="accelZValue">0.0</span></div>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="controls">
            <button id="startBtn" onclick="handleStartTracking()">Start Tracking</button>
            <button id="stopBtn" onclick="stopTracking()" disabled>Stop Tracking</button>
            <button id="pauseBtn" onclick="togglePause()" disabled>Pause</button>
            <button onclick="resetTrip()">Reset Trip</button>
            <button onclick="refillTank()">Refill Tank</button>
            <button id="dataLogBtn" onclick="toggleDataLogging()">Start Data Log</button>
            <button onclick="exportDataLog()">Export Log</button>
            <button onclick="clearDataLog()">Clear Log</button>
        </div>
        
        <div class="status" id="status">
            GPS tracking not started. Click "Start Tracking" to begin.
        </div>

        <!-- iOS Permission Helper -->
        <div class="status" id="iosHelper" style="display: none; background: rgba(255, 255, 0, 0.1); border-color: rgba(255, 255, 0, 0.3);">
            üì± <strong>iOS Users:</strong> You'll be prompted for location and motion sensor permissions.
            Allow both for full functionality (lean angle, RPM, fuel analysis).
        </div>

        <!-- Debug Panel for iOS Troubleshooting -->
        <div class="status" id="debugPanel" style="display: none; background: rgba(0, 255, 255, 0.1); border-color: rgba(0, 255, 255, 0.3);">
            <strong>üîß Debug Info:</strong>
            <div id="debugMessages" style="font-family: monospace; font-size: 0.8em; margin-top: 10px; max-height: 150px; overflow-y: auto;">
                Ready for debugging...
            </div>
        </div>

        <!-- Data Logging Status -->
        <div class="calibration" id="dataLogStatus" style="display: none;">
            <h3>üìä Data Logging Status</h3>
            <div class="gps-info">
                <div class="info-item">
                    <div class="metric-label">Log Entries</div>
                    <div class="info-value" id="logEntries">0</div>
                </div>
                <div class="info-item">
                    <div class="metric-label">Session Duration</div>
                    <div class="info-value" id="logDuration">0:00</div>
                </div>
                <div class="info-item">
                    <div class="metric-label">Data Rate</div>
                    <div class="info-value" id="dataRate">0</div>
                    <div class="metric-label">entries/min</div>
                </div>
                <div class="info-item">
                    <div class="metric-label">Log Size</div>
                    <div class="info-value" id="logSize">0</div>
                    <div class="metric-label">KB</div>
                </div>
            </div>
        </div>
        
        <div class="calibration">
            <h3 onclick="toggleCalibration()" style="cursor: pointer; user-select: none;">üìä Calibration Points <span id="calibrationToggle">‚ñº</span></h3>
            <div class="cal-points" id="calibrationContent" style="display: none;">
                <div>
                    <label>Highway Speed (mph): </label>
                    <input type="number" id="highwaySpeed" value="60" min="30" max="100">
                    <label> ‚Üí MPG: </label>
                    <input type="number" id="highwayMPG" value="45" min="20" max="80">
                </div>
                <div>
                    <label>Local Speed (mph): </label>
                    <input type="number" id="localSpeed" value="30" min="10" max="60">
                    <label> ‚Üí MPG: </label>
                    <input type="number" id="localMPG" value="35" min="15" max="60">
                </div>
                <div>
                    <label>Idle Consumption (gal/hr): </label>
                    <input type="number" id="idleConsumption" value="0.2" min="0.1" max="0.5" step="0.1">
                </div>
            </div>
            
            <h4 style="margin: 20px 0 10px 0; text-align: center;">üîß Engine Configuration</h4>
            <div class="cal-points">
                <div>
                    <label>Cylinders: </label>
                    <select id="engineCylinders">
                        <option value="1">Single (1)</option>
                        <option value="2" selected>Twin (2)</option>
                        <option value="3">Triple (3)</option>
                        <option value="4">Four (4)</option>
                    </select>
                </div>
                <div>
                    <label>Idle RPM: </label>
                    <input type="number" id="idleRPM" value="950" min="600" max="2000" step="50">
                </div>
                <div>
                    <label>Redline RPM: </label>
                    <input type="number" id="redlineRPM" value="8000" min="6000" max="15000" step="100">
                </div>
                <div>
                    <label>Enable RPM Detection: </label>
                    <input type="checkbox" id="enableRPM" checked>
                </div>
            </div>
            <div style="text-align: center; margin-top: 15px;">
                <button onclick="updateCalibration()">Update Calibration</button>
            </div>
        </div>
        
    </div>

    <!-- Version Footer -->
    <div style="text-align: center; padding: 20px; opacity: 0.7; font-size: 0.8em; color: white;">
        v2.6.1 ‚Ä¢ Cornering Analytics Edition ‚Ä¢ Built 2025-09-21 12:03 EST
    </div>

    <!-- Build Info Banner -->
    <div class="install-banner" id="buildBanner" style="background: rgba(0,100,200,0.2); padding: 10px; text-align: center; color: white;">
        üîß Built 2025-09-21 12:03 EST ‚Ä¢ Debugging iOS Issue
    </div>

    <script>
        // IMMEDIATE TEST - Check if JavaScript is working at all
        try {
            alert('JavaScript is working! Loading app...');
        } catch (e) {
            console.error('JavaScript basic test failed:', e);
        }

        // PWA Installation
        let deferredPrompt;
        let isInstalled = false;
        
        window.addEventListener('beforeinstallprompt', (e) => {
            e.preventDefault();
            deferredPrompt = e;
            showInstallBanner();
        });
        
        window.addEventListener('appinstalled', () => {
            isInstalled = true;
            hideInstallBanner();
        });
        
        function showInstallBanner() {
            if (!isInstalled && !localStorage.getItem('installBannerDismissed')) {
                document.getElementById('installBanner').style.display = 'block';
            }
        }
        
        function hideInstallBanner() {
            document.getElementById('installBanner').style.display = 'none';
            localStorage.setItem('installBannerDismissed', 'true');
        }
        
        function installApp() {
            if (deferredPrompt) {
                deferredPrompt.prompt();
                deferredPrompt.userChoice.then((choiceResult) => {
                    if (choiceResult.outcome === 'accepted') {
                        debugLog('‚úÖ User accepted the install prompt');
                    }
                    deferredPrompt = null;
                    hideInstallBanner();
                });
            }
        }
        
        // Service Worker Registration
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                // Register inline service worker
                const swCode = `
                    const CACHE_NAME = 'fuel-tracker-v1';
                    const urlsToCache = [
                        '/',
                        '/offline.html'
                    ];
                    
                    self.addEventListener('install', (event) => {
                        event.waitUntil(
                            caches.open(CACHE_NAME)
                                .then((cache) => {
                                    return cache.addAll(urlsToCache);
                                })
                        );
                    });
                    
                    self.addEventListener('fetch', (event) => {
                        event.respondWith(
                            caches.match(event.request)
                                .then((response) => {
                                    return response || fetch(event.request);
                                })
                        );
                    });
                `;
                
                const blob = new Blob([swCode], { type: 'application/javascript' });
                const swUrl = URL.createObjectURL(blob);
                
                navigator.serviceWorker.register(swUrl)
                    .then((registration) => {
                        debugLog('‚úÖ Service worker registered successfully');
                    })
                    .catch((registrationError) => {
                        debugLog(`‚ùå Service worker registration failed: ${registrationError}`);
                    });
            });
        }
        
        // Prevent zoom on double tap (iOS)
        let lastTouchEnd = 0;
        document.addEventListener('touchend', function (event) {
            const now = (new Date()).getTime();
            if (now - lastTouchEnd <= 300) {
                event.preventDefault();
            }
            lastTouchEnd = now;
        }, false);
        
        // State variables
        let isTracking = false;
        let isPaused = false;
        let watchId = null;
        let lastPosition = null;
        let lastTime = null;
        let fuelUsed = 0;
        let tripDistance = 0;
        let tankCapacity = 4.5;

        // Data logging system
        let dataLog = [];
        let isLogging = false;
        let logStartTime = null;
        let maxLogEntries = 10000; // Limit to prevent memory issues
        let loggingTimer = null; // Timer for 10Hz logging
        
        // RPM Detection variables
        let rpmAudioContext = null;
        let rpmAudioStream = null;
        let rpmAnalyser = null;
        let rpmDataArray = null;
        let rpmAnimationId = null;
        let currentRPM = 0;
        let rpmEnabled = true;

        // Gear shift detection variables
        let rpmHistory = [];
        let lastValidRPM = 0;
        let lastValidRPMTime = 0;
        let gearShiftDetected = false;
        let gearShiftEndTime = 0;

        // Turn safety calculation variables
        let turnSafetySettings = {
            roadSurface: 0.9,        // Dry asphalt coefficient
            tireCondition: 1.0,      // New tire multiplier
            riderExperience: 0.8,    // Conservative for street riding
            safetyMargin: 1.2        // 20% safety margin
        };

        // GPS-based turn detection variables
        let gpsTrackHistory = [];    // Position/bearing history for turn detection
        let currentTurn = null;      // Active turn state
        let turnWarningActive = false;
        let lastGPSBearing = null;
        let bearingHistory = [];

        // Turn detection thresholds
        const TURN_DETECTION = {
            MIN_SPEED: 8,                    // Minimum speed to detect turns (mph)
            BEARING_CHANGE_THRESHOLD: 15,    // Degrees of bearing change to start turn
            TURN_COMPLETION_THRESHOLD: 8,    // Degrees to consider turn complete
            HISTORY_SECONDS: 10,             // Seconds of GPS history to maintain
            SMOOTH_WINDOW: 3,                // GPS readings to smooth for bearing calculation
            WARNING_LEAD_TIME: 2             // Seconds ahead to warn for potential issues
        };

        // Audio harmonic tracking for logging
        let currentHarmonics = {
            dominant: { frequency: 0, amplitude: 0 },
            second: { frequency: 0, amplitude: 0 },
            third: { frequency: 0, amplitude: 0 },
            fourth: { frequency: 0, amplitude: 0 }
        };

        // Fuel injection estimation model (Victory Highball specific)
        const FUEL_INJECTION_MODEL = {
            // Engine specifications
            displacement: 1634,              // Total displacement in cc
            cylinders: 2,                    // V-twin
            cylinderDisplacement: 817,       // cc per cylinder
            compressionRatio: 9.4,

            // Base fuel requirements (cc per stroke at stoichiometric)
            baseFuelPerStroke: 2.2,          // At 80% VE, 14.7:1 AFR

            // Load estimation parameters
            accelThresholds: {
                idle: 0.05,                  // < 0.05 m/s¬≤ = idle/cruise
                light: 0.3,                  // 0.05-0.3 m/s¬≤ = light acceleration
                moderate: 0.8,               // 0.3-0.8 m/s¬≤ = moderate acceleration
                heavy: 1.5                   // > 0.8 m/s¬≤ = heavy acceleration
            },

            // RPM-based volumetric efficiency curve
            veTable: {
                950: 0.40,    // Idle
                1500: 0.60,   // Low cruise
                2000: 0.75,   // Highway cruise
                2500: 0.82,   // Optimal cruise
                3000: 0.88,   // Good power
                4000: 0.93,   // Peak torque
                5000: 0.90,   // High RPM
                6000: 0.85,   // Redline approach
                7000: 0.80    // Over-rev
            },

            // Air-fuel ratio based on load
            afrTable: {
                idle: 14.2,       // Lean for efficiency
                cruise: 14.7,     // Stoichiometric
                light: 13.8,      // Slightly rich
                moderate: 12.8,   // Rich for power
                heavy: 12.0       // Very rich for power/cooling
            }
        };

        // Current fuel injection state
        let currentFuelInjection = {
            perStroke: 0,
            perSecond: 0,
            perMinute: 0,
            throttleLoad: 0,
            estimatedAFR: 14.7
        };

        // iOS detection and permission state
        let iosPermissionsGranted = {
            motion: false,
            orientation: false,
            location: false
        };

        function isIOS() {
            return /iPad|iPhone|iPod/.test(navigator.userAgent) ||
                   (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
        }

        // Debug function for iOS troubleshooting (since no dev console)
        function debugLog(message) {
            const debugPanel = document.getElementById('debugPanel');
            const debugMessages = document.getElementById('debugMessages');

            if (debugPanel && debugMessages) {
                debugPanel.style.display = 'block';
                const timestamp = new Date().toLocaleTimeString();
                debugMessages.innerHTML += `<br>[${timestamp}] ${message}`;
                debugMessages.scrollTop = debugMessages.scrollHeight;
            }

            console.log(message); // Keep console logs for desktop debugging
        }

        // Wrapper function to handle async startTracking with proper error handling
        function handleStartTracking() {
            // Force debug panel to show immediately
            const debugPanel = document.getElementById('debugPanel');
            if (debugPanel) {
                debugPanel.style.display = 'block';
            }

            // Test basic alert first
            alert('Button clicked! Debug panel should appear.');

            debugLog('üîò Start Tracking button clicked');
            document.getElementById('status').textContent = 'Initializing tracking...';

            startTracking().catch(error => {
                debugLog(`‚ùå Start tracking failed: ${error.message}`);
                document.getElementById('status').textContent = `Start tracking failed: ${error.message}`;

                // Re-enable the start button on error
                document.getElementById('startBtn').disabled = false;
                document.getElementById('stopBtn').disabled = true;
                document.getElementById('pauseBtn').disabled = true;
            });
        }
        
        // Load saved data
        window.addEventListener('load', () => {
            loadSavedData();

            // Show iOS permission helper if on iOS
            if (isIOS()) {
                document.getElementById('iosHelper').style.display = 'block';
            }
        });
        
        // Save data when page unloads
        window.addEventListener('beforeunload', () => {
            saveData();
        });
        
        function saveData() {
            const data = {
                fuelUsed,
                tripDistance,
                tankCapacity,
                calibration,
                timestamp: Date.now()
            };
            localStorage.setItem('fuelTrackerData', JSON.stringify(data));
        }
        
        function loadSavedData() {
            const saved = localStorage.getItem('fuelTrackerData');
            if (saved) {
                const data = JSON.parse(saved);
                fuelUsed = data.fuelUsed || 0;
                tripDistance = data.tripDistance || 0;
                tankCapacity = data.tankCapacity || 4.5;
                calibration = data.calibration || calibration;
                
                // Update displays
                document.getElementById('tripDistance').textContent = tripDistance.toFixed(1);
                updateRemainingFuel();
                
                // Update calibration inputs
                document.getElementById('highwaySpeed').value = calibration.highway.speed;
                document.getElementById('highwayMPG').value = calibration.highway.mpg;
                document.getElementById('localSpeed').value = calibration.local.speed;
                document.getElementById('localMPG').value = calibration.local.mpg;
                document.getElementById('idleConsumption').value = calibration.idle.gallonsPerHour;
                
                // Update engine configuration inputs
                document.getElementById('engineCylinders').value = calibration.engine.cylinders;
                document.getElementById('idleRPM').value = calibration.engine.idleRPM;
                document.getElementById('redlineRPM').value = calibration.engine.redlineRPM;
                document.getElementById('enableRPM').checked = calibration.engine.enableRPM;
                
                // Initialize RPM state
                rpmEnabled = calibration.engine.enableRPM;
            }
        }
        
        // Calibration points
        let calibration = {
            highway: {speed: 60, mpg: 45},
            local: {speed: 30, mpg: 35},
            idle: {gallonsPerHour: 0.2}, // Typical motorcycle idle consumption
            engine: {
                cylinders: 2,
                idleRPM: 950,
                redlineRPM: 8000,
                enableRPM: true
            }
        };
        
        function interpolateMPG(speed) {
            const {highway, local} = calibration;
            
            // Handle edge cases
            if (speed <= 0) return local.mpg; // Idling/stopped
            if (speed <= local.speed) {
                // Linear interpolation from 0 to local speed
                const ratio = speed / local.speed;
                return local.mpg * ratio + local.mpg * (1 - ratio) * 0.7; // Assume 70% efficiency at idle
            }
            if (speed >= highway.speed) {
                // Extrapolate beyond highway speed (efficiency typically decreases)
                const speedRatio = speed / highway.speed;
                return highway.mpg / Math.pow(speedRatio, 0.5); // Square root decay
            }
            
            // Linear interpolation between local and highway
            const ratio = (speed - local.speed) / (highway.speed - local.speed);
            return local.mpg + (highway.mpg - local.mpg) * ratio;
        }
        
        function calculateFuelConsumption(speed, timeMinutes, rpm = null) {
            if (timeMinutes <= 0) return 0;
            
            // Handle idle consumption for very low speeds (< 5 mph)
            if (speed < 5) {
                return calibration.idle.gallonsPerHour * (timeMinutes / 60);
            }
            
            // Use advanced RPM-based calculation if available
            if (rpm && rpm > 0 && calibration.engine.enableRPM) {
                return calculateRPMBasedFuelConsumption(speed, rpm, timeMinutes);
            }
            
            // Fallback to speed-only calculation
            const mpg = interpolateMPG(speed);
            const milesTrailed = speed * (timeMinutes / 60);
            return milesTrailed / mpg;
        }
        
        function calculateRPMBasedFuelConsumption(speed, rpm, timeMinutes) {
            const {idleRPM, redlineRPM} = calibration.engine;
            const milesTrailed = speed * (timeMinutes / 60);
            
            // Calculate engine load factor based on RPM vs Speed relationship
            const expectedRPMForSpeed = calculateExpectedRPM(speed);
            const loadFactor = Math.max(0.3, Math.min(2.0, rpm / expectedRPMForSpeed));
            
            // Base MPG from speed interpolation
            const baseMPG = interpolateMPG(speed);
            
            // Apply RPM-based corrections
            const rpmFactor = calculateRPMEfficiencyFactor(rpm);
            const loadPenalty = Math.pow(loadFactor, 0.8); // Higher load = worse efficiency
            
            // Calculate final MPG with RPM considerations
            const finalMPG = baseMPG * rpmFactor / loadPenalty;
            
            return milesTrailed / Math.max(5, finalMPG); // Minimum 5 MPG sanity check
        }
        
        function calculateExpectedRPM(speed) {
            // Estimate expected RPM based on typical motorcycle gearing
            // This is a simplified model - real motorcycles vary significantly
            if (speed < 10) return calibration.engine.idleRPM;
            if (speed < 25) return calibration.engine.idleRPM + (speed - 10) * 100; // Low gears
            if (speed < 45) return 2500 + (speed - 25) * 75; // Mid gears
            return 4000 + (speed - 45) * 50; // High gears
        }
        
        function calculateRPMEfficiencyFactor(rpm) {
            const {idleRPM, redlineRPM} = calibration.engine;
            
            // Most efficient RPM range is typically 25-40% of redline
            const efficientRPMMin = redlineRPM * 0.25;
            const efficientRPMMax = redlineRPM * 0.40;
            
            if (rpm < idleRPM) return 0.4; // Very inefficient below idle
            if (rpm >= idleRPM && rpm < efficientRPMMin) {
                // Gradually improve from idle to efficient range
                return 0.7 + 0.3 * (rpm - idleRPM) / (efficientRPMMin - idleRPM);
            }
            if (rpm >= efficientRPMMin && rpm <= efficientRPMMax) {
                return 1.0; // Peak efficiency
            }
            if (rpm > efficientRPMMax) {
                // Efficiency degrades after peak range
                const overRevFactor = Math.min(1.0, (redlineRPM - rpm) / (redlineRPM - efficientRPMMax));
                return 0.6 + 0.4 * overRevFactor;
            }
            
            return 0.5; // Default fallback
        }
        
        async function startTracking() {
            debugLog('üìç startTracking() called');

            if (!navigator.geolocation) {
                debugLog('‚ùå GPS not supported by browser');
                document.getElementById('status').textContent = 'GPS not supported by this browser.';
                throw new Error('GPS not supported by this browser');
            }

            debugLog('‚úÖ GPS supported, checking iOS permissions...');

            // iOS 13+ requires explicit permission for motion sensors
            if (isIOS() && typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                debugLog('üì± iOS detected, requesting motion permissions...');
                document.getElementById('status').textContent = 'Requesting iOS motion sensor permissions...';

                try {
                    debugLog('üîÑ Requesting DeviceMotionEvent permission...');
                    const motionPermission = await DeviceMotionEvent.requestPermission();
                    iosPermissionsGranted.motion = (motionPermission === 'granted');

                    if (!iosPermissionsGranted.motion) {
                        debugLog(`‚ùå DeviceMotionEvent permission: ${motionPermission}`);
                    } else {
                        debugLog('‚úÖ DeviceMotionEvent permission granted');
                    }
                } catch (error) {
                    debugLog(`‚ùå DeviceMotionEvent permission error: ${error.message}`);
                    iosPermissionsGranted.motion = false;
                }

                // Also request orientation permission if available
                if (typeof DeviceOrientationEvent !== 'undefined' && typeof DeviceOrientationEvent.requestPermission === 'function') {
                    try {
                        debugLog('üîÑ Requesting DeviceOrientationEvent permission...');
                        const orientationPermission = await DeviceOrientationEvent.requestPermission();
                        iosPermissionsGranted.orientation = (orientationPermission === 'granted');

                        if (!iosPermissionsGranted.orientation) {
                            debugLog(`‚ùå DeviceOrientationEvent permission denied`);
                        } else {
                            debugLog('‚úÖ DeviceOrientationEvent permission granted');
                        }
                    } catch (error) {
                        debugLog(`‚ùå DeviceOrientationEvent permission error: ${error.message}`);
                        iosPermissionsGranted.orientation = false;
                    }
                }

                // Update status based on permissions
                if (!iosPermissionsGranted.motion && !iosPermissionsGranted.orientation) {
                    document.getElementById('status').textContent = 'Motion sensor permissions denied. GPS-only mode.';
                } else if (!iosPermissionsGranted.motion) {
                    document.getElementById('status').textContent = 'Limited motion sensors. Some features may be unavailable.';
                }
            } else if (!isIOS()) {
                // Non-iOS devices should have sensor access
                iosPermissionsGranted.motion = true;
                iosPermissionsGranted.orientation = true;
            }

            // Request GPS permission and start tracking
            debugLog('üõ∞Ô∏è Starting GPS tracking...');
            document.getElementById('status').textContent = 'Requesting GPS location permission...';

            const options = {
                enableHighAccuracy: true,
                timeout: 10000,
                maximumAge: 1000
            };

            try {
                debugLog('üìç Calling navigator.geolocation.watchPosition...');
                watchId = navigator.geolocation.watchPosition(
                    handlePositionUpdate,
                    handlePositionError,
                    options
                );

                debugLog(`‚úÖ GPS watchPosition started, watchId: ${watchId}`);

                isTracking = true;
                isPaused = false;
                document.getElementById('startBtn').disabled = true;
                document.getElementById('stopBtn').disabled = false;
                document.getElementById('pauseBtn').disabled = false;
                document.getElementById('status').textContent = 'GPS tracking started. Waiting for position data...';

                debugLog('‚úÖ UI updated, tracking state set');

            } catch (error) {
                console.error('GPS permission error:', error);
                document.getElementById('status').textContent = 'GPS permission error: ' + error.message;
                throw error; // Re-throw to be caught by handleStartTracking
            }

            // Keep screen on (where supported)
            if ('wakeLock' in navigator) {
                navigator.wakeLock.request('screen').catch(() => {});
            }
            
            // Start RPM detection if enabled
            if (rpmEnabled && calibration.engine.enableRPM) {
                try {
                    startRPMDetection();
                } catch (error) {
                    debugLog(`‚ùå RPM detection failed: ${error}`);
                    document.getElementById('status').textContent += ' (RPM detection unavailable)';
                }
            }

            // Start IMU motion detection with error handling
            try {
                startMotionDetection();
            } catch (error) {
                debugLog(`‚ùå Motion detection failed: ${error}`);
                document.getElementById('status').textContent += ' (Motion sensors unavailable)';
            }

            // Start daylight tracking
            startDaylightTracking();
        }
        
        function stopTracking() {
            if (watchId) {
                navigator.geolocation.clearWatch(watchId);
                watchId = null;
            }
            
            isTracking = false;
            isPaused = false;
            lastPosition = null;
            lastTime = null;
            
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            document.getElementById('pauseBtn').disabled = true;
            document.getElementById('pauseBtn').textContent = 'Pause';
            document.getElementById('status').textContent = 'GPS tracking stopped.';
            document.getElementById('currentSpeed').textContent = '0';
            document.getElementById('currentMPG').textContent = '--';
            
            // Stop RPM detection
            stopRPMDetection();

            
            // Stop IMU motion detection
            stopMotionDetection();

            // Stop daylight tracking
            stopDaylightTracking();

            saveData();
        }
        
        function togglePause() {
            isPaused = !isPaused;
            const pauseBtn = document.getElementById('pauseBtn');
            
            if (isPaused) {
                pauseBtn.textContent = 'Resume';
                document.getElementById('status').textContent = 'Tracking paused - fuel consumption stopped.';
            } else {
                pauseBtn.textContent = 'Pause';
                document.getElementById('status').textContent = 'Tracking resumed - fuel consumption active.';
            }
        }
        
        function handlePositionUpdate(position) {
            const currentTime = Date.now();
            const currentPosition = {
                lat: position.coords.latitude,
                lon: position.coords.longitude,
                accuracy: position.coords.accuracy
            };
            
            document.getElementById('status').textContent = 
                `GPS active. Accuracy: ¬±${Math.round(position.coords.accuracy)}m`;
            
            if (lastPosition && lastTime) {
                const timeDelta = (currentTime - lastTime) / 1000 / 60; // minutes
                
                if (timeDelta > 0.1) { // Update every 6 seconds minimum
                    const distance = calculateDistance(lastPosition, currentPosition);
                    const speed = (distance / timeDelta) * 60; // mph
                    
                    // Filter out unrealistic speeds and poor GPS accuracy
                    if (speed <= 150 && position.coords.accuracy <= 20) { // Stricter accuracy requirement
                        updateMetrics(speed, timeDelta, distance);

                        // Update GPS turn detection
                        updateGPSTrackHistory(currentPosition, speed, currentTime);
                    }

                    lastTime = currentTime;
                    lastPosition = currentPosition;
                }
            } else {
                // First position
                lastTime = currentTime;
                lastPosition = currentPosition;

                // Update daylight calculation with new GPS position
                updateDaylightDisplay();
            }
        }
        
        function handlePositionError(error) {
            let message = 'GPS error: ';
            switch(error.code) {
                case error.PERMISSION_DENIED:
                    message += 'Location access denied by user.';
                    break;
                case error.POSITION_UNAVAILABLE:
                    message += 'Location information unavailable.';
                    break;
                case error.TIMEOUT:
                    message += 'Location request timed out.';
                    break;
                default:
                    message += 'Unknown error occurred.';
                    break;
            }
            document.getElementById('status').textContent = message;
        }
        
        function calculateDistance(pos1, pos2) {
            // Haversine formula for distance in miles
            const R = 3959; // Earth's radius in miles
            const dLat = (pos2.lat - pos1.lat) * Math.PI / 180;
            const dLon = (pos2.lon - pos1.lon) * Math.PI / 180;
            const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                      Math.cos(pos1.lat * Math.PI / 180) * Math.cos(pos2.lat * Math.PI / 180) *
                      Math.sin(dLon/2) * Math.sin(dLon/2);
            const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
            return R * c;
        }
        
        function updateMetrics(speed, timeMinutes, distance) {
            // Update current readings
            document.getElementById('currentSpeed').textContent = Math.round(speed);

            // Calculate MPG considering RPM if available
            let currentMPG;
            if (currentRPM > 0 && calibration.engine.enableRPM) {
                // Use RPM-aware MPG calculation
                const baseMPG = interpolateMPG(speed);
                const rpmFactor = calculateRPMEfficiencyFactor(currentRPM);
                const expectedRPM = calculateExpectedRPM(speed);
                const loadFactor = Math.max(0.3, Math.min(2.0, currentRPM / expectedRPM));
                const loadPenalty = Math.pow(loadFactor, 0.8);
                currentMPG = baseMPG * rpmFactor / loadPenalty;
            } else {
                currentMPG = interpolateMPG(speed);
            }

            document.getElementById('currentMPG').textContent = currentMPG.toFixed(1);

            // Only calculate fuel consumption and distance if not paused
            if (!isPaused) {
                const fuelConsumed = calculateFuelConsumption(speed, timeMinutes, currentRPM);
                fuelUsed += fuelConsumed;
                tripDistance += distance;
            }

            // Note: Data logging now happens at 10Hz via timer, not GPS updates

            // Update displays - fuel is handled by updateRemainingFuel()
            updateRemainingFuel();

            // Estimate range based on current MPG
            const fuelRemaining = Math.max(0, tankCapacity - fuelUsed);
            const estimatedRange = fuelRemaining * currentMPG;
            document.getElementById('estimatedRange').textContent =
                estimatedRange > 0 ? Math.round(estimatedRange) : '0';

            document.getElementById('tripDistance').textContent = tripDistance.toFixed(1);

            // Update turn safety calculations
            updateTurnSafetyDisplay();

            // Update fuel injection estimates
            updateFuelInjectionEstimate();
        }
        
        function resetTrip() {
            fuelUsed = 0;
            tripDistance = 0;
            document.getElementById('tripDistance').textContent = '0.0';
            updateRemainingFuel();
            saveData();
        }
        
        function refillTank() {
            fuelUsed = 0;
            updateRemainingFuel();
            saveData();
        }
        
        function formatFuelUsed(gallons) {
            // Format as whole gallons + whole ounces (4g 2oz)
            const wholeGallons = Math.floor(gallons);
            const remainingGallons = gallons - wholeGallons;
            const ounces = Math.round(remainingGallons * 128); // 128 fl oz per gallon

            if (wholeGallons === 0 && ounces === 0) {
                return "0g 0oz";
            }
            return `${wholeGallons}g ${ounces}oz`;
        }

        function formatFuelRemaining(gallons) {
            // Whole gallons if >= 1, otherwise whole fluid ounces
            if (gallons >= 1) {
                return `${Math.round(gallons)}g`;
            } else {
                const ounces = Math.round(gallons * 128); // 128 fl oz per gallon
                return `${ounces}oz`;
            }
        }

        function updateRemainingFuel() {
            const fuelRemaining = Math.max(0, tankCapacity - fuelUsed);
            document.getElementById('fuelUsed').textContent = formatFuelUsed(fuelUsed);
            document.getElementById('fuelRemaining').textContent = formatFuelRemaining(fuelRemaining);
        }
        
        function updateCalibration() {
            calibration.highway.speed = parseInt(document.getElementById('highwaySpeed').value);
            calibration.highway.mpg = parseInt(document.getElementById('highwayMPG').value);
            calibration.local.speed = parseInt(document.getElementById('localSpeed').value);
            calibration.local.mpg = parseInt(document.getElementById('localMPG').value);
            calibration.idle.gallonsPerHour = parseFloat(document.getElementById('idleConsumption').value);
            
            // Update engine configuration
            calibration.engine.cylinders = parseInt(document.getElementById('engineCylinders').value);
            calibration.engine.idleRPM = parseInt(document.getElementById('idleRPM').value);
            calibration.engine.redlineRPM = parseInt(document.getElementById('redlineRPM').value);
            calibration.engine.enableRPM = document.getElementById('enableRPM').checked;
            rpmEnabled = calibration.engine.enableRPM;
            
            // Update current MPG display if tracking
            if (isTracking) {
                const currentSpeed = parseInt(document.getElementById('currentSpeed').textContent);
                const currentMPG = interpolateMPG(currentSpeed);
                document.getElementById('currentMPG').textContent = currentMPG.toFixed(1);
            }
            
            saveData();
        }
        
        
        // RPM Detection Functions
        async function startRPMDetection() {
            if (!rpmEnabled || !calibration.engine.enableRPM) return;
            
            try {
                // Request microphone access for RPM detection
                rpmAudioStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false,
                        sampleRate: 22050
                    }
                });
                
                // Create audio context for RPM analysis
                rpmAudioContext = new (window.AudioContext || window.webkitAudioContext)();
                const source = rpmAudioContext.createMediaStreamSource(rpmAudioStream);
                
                // Set up analyzer for RPM detection
                rpmAnalyser = rpmAudioContext.createAnalyser();
                rpmAnalyser.fftSize = 2048;
                rpmAnalyser.smoothingTimeConstant = 0.8; // Smooth RPM readings
                
                const bufferLength = rpmAnalyser.frequencyBinCount;
                rpmDataArray = new Uint8Array(bufferLength);
                
                source.connect(rpmAnalyser);
                
                // Start RPM analysis loop
                analyzeRPM();
                
            } catch (error) {
                debugLog(`‚ùå RPM detection failed: ${error.message}`);
                // Continue with GPS-only tracking
            }
        }
        
        function analyzeRPM() {
            if (!rpmAnalyser || !rpmEnabled) return;
            
            rpmAnalyser.getByteFrequencyData(rpmDataArray);
            
            const cylinders = calibration.engine.cylinders;
            const idleRPM = calibration.engine.idleRPM;
            const redlineRPM = calibration.engine.redlineRPM;
            
            // Calculate expected frequency ranges for this engine
            const minFreq = (idleRPM * cylinders) / 120; // Fundamental at idle
            const maxFreq = (redlineRPM * cylinders) / 60; // 2nd harmonic at redline
            
            // Convert frequency to FFT bin indices
            const sampleRate = rpmAudioContext.sampleRate;
            const binSize = sampleRate / rpmAnalyser.fftSize;
            const minBin = Math.max(1, Math.floor(minFreq / binSize));
            const maxBin = Math.min(rpmDataArray.length - 1, Math.floor(maxFreq / binSize));
            
            // Find multiple peaks in engine frequency range
            const peaks = [];
            
            // Find all significant peaks above threshold - much higher to prevent false positives
            for (let i = minBin; i <= maxBin; i++) {
                if (rpmDataArray[i] > 180) { // Even higher threshold to eliminate ambient noise
                    // Check if this is a local maximum
                    const isLocalMax = (i === 0 || rpmDataArray[i] > rpmDataArray[i-1]) &&
                                      (i === rpmDataArray.length-1 || rpmDataArray[i] > rpmDataArray[i+1]);

                    if (isLocalMax) {
                        const frequency = i * binSize;
                        peaks.push({ bin: i, amplitude: rpmDataArray[i], frequency });
                    }
                }
            }

            // Sort peaks by amplitude (strongest first)
            peaks.sort((a, b) => b.amplitude - a.amplitude);

            // Update harmonic tracking for logging (capture top 4 peaks)
            currentHarmonics.dominant = peaks[0] || { frequency: 0, amplitude: 0 };
            currentHarmonics.second = peaks[1] || { frequency: 0, amplitude: 0 };
            currentHarmonics.third = peaks[2] || { frequency: 0, amplitude: 0 };
            currentHarmonics.fourth = peaks[3] || { frequency: 0, amplitude: 0 };

            // Detect gear shift conditions
            detectGearShift();

            // Adaptive thresholds based on speed, gear shifts, and RPM context
            const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;

            // Speed-based ambient noise adjustment (higher speeds = more road/wind noise)
            const speedNoiseFactor = Math.min(1.5, 1.0 + (currentSpeed - 20) * 0.01); // Increase threshold 1% per mph over 20

            // RPM-based engine volume adjustment (cruising RPM quieter than idle)
            const expectedRPM = calculateExpectedRPM(currentSpeed);
            const rpmVolumeFactor = expectedRPM < calibration.engine.idleRPM * 1.5 ? 0.7 : 1.0; // Quieter at low cruise RPM

            // Gear shift sensitivity boost
            const gearShiftFactor = gearShiftDetected ? 0.6 : 1.0; // Much more sensitive during gear shifts

            // Recent RPM loss penalty (if we lost RPM detection recently, be more sensitive)
            const timeSinceLastRPM = Date.now() - (lastValidRPMTime || 0);
            const rpmLossFactor = (timeSinceLastRPM > 2000 && timeSinceLastRPM < 10000) ? 0.8 : 1.0;

            // Combined adaptive threshold
            const baseThreshold = 180; // Lower base threshold
            const adaptiveThreshold = baseThreshold * speedNoiseFactor * rpmVolumeFactor * gearShiftFactor * rpmLossFactor;

            const baseConfidenceThreshold = gearShiftDetected ? 250 : 350; // Lower confidence requirement

            // Calculate RPM from detected peaks - adaptive threshold
            if (peaks.length > 0 && peaks[0].amplitude > adaptiveThreshold) {
                let bestRPM = 0;
                let bestConfidence = 0;
                
                // Smart harmonic analysis - try multiple interpretations of each peak
                for (const peak of peaks.slice(0, 3)) { // Check top 3 peaks
                    const freq = peak.frequency;
                    
                    // Test different harmonic interpretations
                    const rpmCandidates = [
                        { rpm: (freq * 120) / cylinders, harmonic: 1, confidence: peak.amplitude * 0.8 }, // Fundamental
                        { rpm: (freq * 60) / cylinders, harmonic: 2, confidence: peak.amplitude * 1.1 },  // 2nd harmonic
                        { rpm: (freq * 40) / cylinders, harmonic: 3, confidence: peak.amplitude * 0.9 },  // 3rd harmonic
                        { rpm: (freq * 30) / cylinders, harmonic: 4, confidence: peak.amplitude * 1.3 }   // 4th harmonic (strong in V-Twins)
                    ];
                    
                    for (const candidate of rpmCandidates) {
                        // Check if RPM is within reasonable engine range
                        if (candidate.rpm >= idleRPM * 0.7 && candidate.rpm <= redlineRPM * 1.3) {
                            // Boost confidence for readings near expected idle
                            let adjustedConfidence = candidate.confidence;
                            if (candidate.rpm >= idleRPM * 0.8 && candidate.rpm <= idleRPM * 1.5) {
                                adjustedConfidence *= 1.5; // Favor idle range readings
                            }
                            
                            if (adjustedConfidence > bestConfidence) {
                                bestRPM = candidate.rpm;
                                bestConfidence = adjustedConfidence;
                            }
                        }
                    }
                }
                
                // Apply adaptive validation based on gear shift state
                if (bestRPM > 0 && bestConfidence > baseConfidenceThreshold) {
                
                    // Add speed/RPM correlation validation
                    const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;
                    const expectedRPM = calculateExpectedRPM(currentSpeed);
                    const rpmRatio = bestRPM / expectedRPM;

                    // Adaptive RPM validation and smoothing based on gear shift state
                    const rpmChangeRate = Math.abs(bestRPM - currentRPM) / Math.max(currentRPM, bestRPM, 1);

                    if (gearShiftDetected) {
                        // During gear shifts, allow larger RPM changes and use faster response
                        if (rpmRatio < 0.2 || rpmRatio > 4.0) {
                            currentRPM = currentRPM * 0.92; // Gentle decay for invalid readings
                        } else {
                            // Faster response during gear shifts
                            currentRPM = currentRPM * 0.75 + bestRPM * 0.25;
                        }
                    } else {
                        // Normal operation - stricter validation, slower response
                        if (rpmRatio < 0.3 || rpmRatio > 3.0) {
                            currentRPM = currentRPM * 0.95; // Gradually decay invalid readings
                        } else {
                            // Conservative smoothing for stable operation
                            currentRPM = currentRPM * 0.90 + bestRPM * 0.10;
                        }
                    }

                    // Update RPM history for gear shift detection
                    lastValidRPM = bestRPM;
                    lastValidRPMTime = Date.now(); // Track when we last had valid RPM
                    document.getElementById('currentRPM').textContent = Math.round(currentRPM);
                } else {
                    // No confident reading - decay current RPM
                    if (currentRPM > idleRPM * 0.5) {
                        currentRPM = currentRPM * 0.92; // Gradual decay
                        document.getElementById('currentRPM').textContent = Math.round(currentRPM);
                    } else {
                        currentRPM = 0;
                        document.getElementById('currentRPM').textContent = '--';
                    }
                }
            } else {
                // No strong signal - possibly idle or engine off
                if (currentRPM > idleRPM * 0.5) {
                    currentRPM = currentRPM * 0.9; // Gradually decrease
                    document.getElementById('currentRPM').textContent = Math.round(currentRPM);
                } else {
                    document.getElementById('currentRPM').textContent = '--';
                    currentRPM = 0;
                }
            }
            
            // Update at 15 FPS instead of 60 FPS for better performance
            rpmAnimationId = setTimeout(analyzeRPM, 67); // 1000ms / 15fps ‚âà 67ms
        }


        function detectGearShift() {
            const now = Date.now();

            // Maintain RPM history for gear shift detection (last 3 seconds)
            rpmHistory.push({ rpm: currentRPM, timestamp: now });
            rpmHistory = rpmHistory.filter(entry => now - entry.timestamp < 3000);

            // Reset gear shift flag if enough time has passed
            if (gearShiftDetected && now > gearShiftEndTime) {
                gearShiftDetected = false;
            }

            // Check for RPM detection loss (potential gear shift indicator)
            const timeSinceLastValidRPM = Date.now() - (lastValidRPMTime || 0);
            const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;

            // If we lost RPM detection at highway speeds, likely a gear shift
            if (timeSinceLastValidRPM > 1500 && timeSinceLastValidRPM < 8000 && currentSpeed > 25 && !gearShiftDetected) {
                gearShiftDetected = true;
                gearShiftEndTime = now + 5000; // Extend sensitive period for 5 seconds
                debugLog(`‚öôÔ∏è Gear shift detected via RPM loss at ${currentSpeed} mph`);
            }

            // Only check for traditional gear shift detection if we have enough history and current RPM > idle
            if (rpmHistory.length < 5 || currentRPM < calibration.engine.idleRPM) {
                return;
            }

            // Calculate RPM trend over last 1.5 seconds
            const recentHistory = rpmHistory.filter(entry => now - entry.timestamp < 1500);
            if (recentHistory.length < 3) return;

            const oldestRPM = recentHistory[0].rpm;
            const newestRPM = recentHistory[recentHistory.length - 1].rpm;
            const rpmDrop = oldestRPM - newestRPM;
            const rpmDropPercent = rpmDrop / Math.max(oldestRPM, 1);

            // Detect gear shift conditions:
            // 1. Significant RPM drop (>15% and >300 RPM) over short time
            // 2. Current speed is maintained or increasing (rules out deceleration)
            const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;

            if (rpmDropPercent > 0.15 && rpmDrop > 300 && currentSpeed > 10) {
                // Check if speed is stable/increasing (not just braking)
                const speedElement = document.getElementById('currentSpeed');
                const previousSpeed = parseFloat(speedElement.getAttribute('data-prev-speed')) || currentSpeed;
                speedElement.setAttribute('data-prev-speed', currentSpeed);

                // If speed is maintained/increasing during RPM drop, likely gear shift
                if (currentSpeed >= previousSpeed * 0.95) {
                    gearShiftDetected = true;
                    gearShiftEndTime = now + 2000; // Maintain gear shift mode for 2 seconds
                    debugLog(`‚öôÔ∏è Gear shift detected: RPM ${oldestRPM} ‚Üí ${newestRPM} (${(rpmDropPercent*100).toFixed(1)}% drop) at ${currentSpeed} mph`);
                }
            }
        }
        
        function stopRPMDetection() {
            if (rpmAnimationId) {
                clearTimeout(rpmAnimationId);
                rpmAnimationId = null;
            }
            
            if (rpmAudioStream) {
                rpmAudioStream.getTracks().forEach(track => track.stop());
                rpmAudioStream = null;
            }
            
            if (rpmAudioContext) {
                rpmAudioContext.close();
                rpmAudioContext = null;
            }
            
            rpmAnalyser = null;
            rpmDataArray = null;
            currentRPM = 0;
            document.getElementById('currentRPM').textContent = '--';
        }
        
        // IMU and Motion Detection
        let motionEnabled = false;
        let currentAccel = { x: 0, y: 0, z: 0 };
        let currentGyro = { x: 0, y: 0, z: 0 };
        let currentRollAngle = 0;
        let currentLateralG = 0;
        let motionAnimationId = null;

        // Roll angle filtering variables - for static tilt measurement
        let smoothedAccel = { x: 0, y: 0, z: 0 }; // Low-pass filtered for gravity-only measurement
        let rollAngleCalibrationOffset = 0;

        // Daylight calculation variables
        let lastSunsetCalculation = null;
        let sunsetTime = null;
        let daylightUpdateInterval = null;
        
        function startMotionDetection() {
            // Enhanced error handling and fallback behavior
            if (!('DeviceMotionEvent' in window)) {
                debugLog('‚ö†Ô∏è DeviceMotionEvent not supported - using fallback simulation');
                enableMotionFallback();
                return;
            }

            try {
                if (typeof DeviceMotionEvent.requestPermission === 'function') {
                    // iOS 13+ permission request with enhanced error handling
                    DeviceMotionEvent.requestPermission()
                        .then(permission => {
                            if (permission === 'granted') {
                                enableMotionListeners();
                            } else {
                                debugLog('‚ùå Motion permission denied - using limited functionality');
                                showMotionPermissionMessage();
                            }
                        })
                        .catch(error => {
                            console.error('Motion permission request failed:', error);
                            enableMotionFallback();
                        });
                } else {
                    // Android and older iOS with error handling
                    enableMotionListeners();
                }
            } catch (error) {
                console.error('Motion detection initialization failed:', error);
                enableMotionFallback();
            }
        }

        function showMotionPermissionMessage() {
            // Show user-friendly message about motion permission
            document.getElementById('accelMagnitude').textContent = '--';
            document.getElementById('accelXValue').textContent = '--';
            document.getElementById('accelYValue').textContent = '--';
            document.getElementById('accelZValue').textContent = '--';

            // Add a subtle visual indicator
            const arrow = document.getElementById('accelArrow');
            arrow.setAttribute('stroke', '#888888');
            arrow.setAttribute('stroke-dasharray', '5,5');
        }

        function enableMotionFallback() {
            // Provide basic fallback when motion detection fails
            motionEnabled = false;
            debugLog('‚ö†Ô∏è Using motion detection fallback');

            // Show placeholder values
            document.getElementById('accelMagnitude').textContent = '0.0';
            document.getElementById('accelXValue').textContent = '0.0';
            document.getElementById('accelYValue').textContent = '0.0';
            document.getElementById('accelZValue').textContent = '0.0';
        }
        
        function enableMotionListeners() {
            motionEnabled = true;

            // Enhanced motion event listener with validation
            const motionHandler = (event) => {
                try {
                    // Validate and sanitize acceleration data
                    // Use accelerationIncludingGravity as it's more widely supported on mobile
                    const accelData = event.accelerationIncludingGravity || event.acceleration;
                    if (accelData) {
                        const accelX = accelData.x;
                        const accelY = accelData.y;
                        const accelZ = accelData.z;

                        // Filter out null/undefined values and extreme outliers
                        currentAccel.x = (accelX !== null && !isNaN(accelX) && Math.abs(accelX) < 50) ? accelX : currentAccel.x;
                        currentAccel.y = (accelY !== null && !isNaN(accelY) && Math.abs(accelY) < 50) ? accelY : currentAccel.y;
                        currentAccel.z = (accelZ !== null && !isNaN(accelZ) && Math.abs(accelZ) < 50) ? accelZ : currentAccel.z;
                    }

                    // Validate and sanitize rotation data
                    if (event.rotationRate) {
                        const gyroX = event.rotationRate.alpha;
                        const gyroY = event.rotationRate.beta;
                        const gyroZ = event.rotationRate.gamma;

                        // Filter out null/undefined values and extreme outliers
                        currentGyro.x = (gyroX !== null && !isNaN(gyroX) && Math.abs(gyroX) < 360) ? gyroX : currentGyro.x;
                        currentGyro.y = (gyroY !== null && !isNaN(gyroY) && Math.abs(gyroY) < 360) ? gyroY : currentGyro.y;
                        currentGyro.z = (gyroZ !== null && !isNaN(gyroZ) && Math.abs(gyroZ) < 360) ? gyroZ : currentGyro.z;
                    }
                } catch (error) {
                    console.warn('Motion data processing error:', error);
                    // Continue with existing values rather than crashing
                }
            };

            // Add motion event listener with error handling
            try {
                window.addEventListener('devicemotion', motionHandler, { passive: true });

                // Timeout check to ensure motion detection is working
                let motionCheckTimeout = setTimeout(() => {
                    const totalAccel = Math.abs(currentAccel.x) + Math.abs(currentAccel.y) + Math.abs(currentAccel.z);
                    if (totalAccel === 0) {
                        console.warn('No motion data received - device may not support motion events');
                        showMotionPermissionMessage();
                    }
                }, 3000);

                // Clear timeout when we get first motion data
                const firstMotionHandler = () => {
                    clearTimeout(motionCheckTimeout);
                    window.removeEventListener('devicemotion', firstMotionHandler);
                };
                window.addEventListener('devicemotion', firstMotionHandler, { once: true, passive: true });

            } catch (error) {
                console.error('Failed to add motion event listeners:', error);
                enableMotionFallback();
                return;
            }

            // Start 3D vector visualization updates
            updateAccelerationVector();
        }
        
        function updateAccelerationVector() {
            if (!motionEnabled) return;

            // Get raw acceleration data
            let { x, y, z } = currentAccel;

            // Adjust coordinate system for motorcycle context
            // X: Left(-) to Right(+) when riding
            // Y: Back(-) to Forward(+) when riding
            // Z: Down(-) to Up(+) when riding

            // Apply device orientation correction for landscape use
            if (screen.orientation && screen.orientation.angle) {
                const angle = screen.orientation.angle;
                if (angle === 90 || angle === 270) {
                    // Landscape mode - swap and adjust coordinates
                    const tempX = x;
                    x = angle === 90 ? -y : y;
                    y = angle === 90 ? tempX : -tempX;
                }
            }

            // Calculate magnitude and individual components
            const magnitude = Math.sqrt(x*x + y*y + z*z);

            // Calculate roll angle with better filtering
            calculateRollAngle(x, y, z);

            // Calculate lateral G-force (sideways acceleration in G units)
            // Y-axis represents left/right acceleration relative to motorcycle
            // Convert from m/s¬≤ to G (1G = 9.81 m/s¬≤)
            currentLateralG = y / 9.81;

            // Update displays
            updateRollDisplay(currentRollAngle);
            updateLateralGDisplay(currentLateralG);

            // Update text displays with proper precision - show all values in G units
            document.getElementById('accelMagnitude').textContent = (magnitude / 9.81).toFixed(2) + 'g';
            document.getElementById('accelXValue').textContent = (x / 9.81).toFixed(2) + 'g';
            document.getElementById('accelYValue').textContent = (y / 9.81).toFixed(2) + 'g';
            document.getElementById('accelZValue').textContent = (z / 9.81).toFixed(2) + 'g';

            // Scaling optimized for road vehicle G-forces (0.1g to 1.5g typical range)
            const maxDisplayLength = 40; // Maximum line length in SVG units
            const sensitivityThreshold = 0.1; // Show even gentle accelerations (0.1g)
            const roadVehicleScale = 30; // Scale factor optimized for typical road forces

            // Linear scaling appropriate for road vehicle dynamics
            const getScaledValue = (value) => {
                if (Math.abs(value) < sensitivityThreshold) return 0;

                // Direct linear scaling - length proportional to G-force
                // 1g = full scale (40 SVG units)
                return Math.sign(value) * Math.min(maxDisplayLength, Math.abs(value) * roadVehicleScale);
            };

            // Calculate scaled display coordinates
            const displayX = getScaledValue(x);
            const displayY = getScaledValue(-y); // Invert Y for SVG coordinate system
            const displayZ = getScaledValue(z);

            // 3D to 2D projection for main vector
            // Project Z-axis using isometric perspective (Z affects both X and Y)
            const projectedX = displayX + (displayZ * 0.5); // Z shifts X slightly
            const projectedY = displayY - (displayZ * 0.3); // Z shifts Y up/down

            // Update main acceleration vector
            const arrow = document.getElementById('accelArrow');
            arrow.setAttribute('x2', projectedX.toFixed(1));
            arrow.setAttribute('y2', projectedY.toFixed(1));

            // Update component vectors (show individual axis contributions)
            document.getElementById('accelX').setAttribute('x2', displayX.toFixed(1));
            document.getElementById('accelX').setAttribute('y2', '0');

            document.getElementById('accelY').setAttribute('x2', '0');
            document.getElementById('accelY').setAttribute('y2', displayY.toFixed(1));

            // Z-axis shown as diagonal projection
            const zProjectedX = displayZ * 0.5;
            const zProjectedY = -displayZ * 0.3;
            document.getElementById('accelZ').setAttribute('x2', zProjectedX.toFixed(1));
            document.getElementById('accelZ').setAttribute('y2', zProjectedY.toFixed(1));

            // Color coding based on typical road vehicle G-force ranges
            let arrowColor = '#00ff00'; // Green for normal driving (0-0.3g)
            let strokeWidth = 3;

            if (magnitude > 0.3 && magnitude <= 0.6) {
                arrowColor = '#ffff00'; // Yellow for moderate (0.3-0.6g)
                strokeWidth = 3;
            } else if (magnitude > 0.6 && magnitude <= 1.0) {
                arrowColor = '#ff8800'; // Orange for hard driving (0.6-1.0g)
                strokeWidth = 4;
            } else if (magnitude > 1.0) {
                arrowColor = '#ff0000'; // Red for emergency/extreme (>1.0g)
                strokeWidth = 5;
            }

            // Apply visual updates (no arrowhead reference needed)
            arrow.setAttribute('stroke', arrowColor);
            arrow.setAttribute('stroke-width', strokeWidth);

            // Subtle glow effect only for significant accelerations (>0.5g)
            if (magnitude > 0.5) {
                arrow.style.filter = `drop-shadow(0 0 ${Math.min(6, magnitude * 4)}px ${arrowColor})`;
            } else {
                arrow.style.filter = 'none';
            }

            // Continue updates at 15fps to match RPM detection
            motionAnimationId = setTimeout(updateAccelerationVector, 67);
        }

        function calculateRollAngle(x, y, z) {
            // Calculate static tilt angle relative to gravity (not dynamic motion)
            // This measures the angle of the device/bike relative to vertical

            // Apply heavy low-pass filtering to isolate gravity from motion acceleration
            // This filters out quick movements and keeps only the static tilt component
            const alpha = 0.7; // Heavy smoothing (70% old value, 30% new) - 20% more responsive

            // Low-pass filter to isolate gravity from motion
            smoothedAccel.x = smoothedAccel.x * alpha + x * (1 - alpha);
            smoothedAccel.y = smoothedAccel.y * alpha + y * (1 - alpha);
            smoothedAccel.z = smoothedAccel.z * alpha + z * (1 - alpha);

            // Use smoothed values for tilt calculation (gravity vector only)
            const gx = smoothedAccel.x;
            const gy = smoothedAccel.y;
            const gz = smoothedAccel.z;

            // Calculate roll angle from gravity vector
            // Roll = rotation around front-to-back axis (left/right tilt)
            // Use atan2 for full 360-degree range
            const rollAngleRad = Math.atan2(gx, Math.sqrt(gy*gy + gz*gz));
            let rollAngle = rollAngleRad * (180 / Math.PI);

            // Apply small deadband for zero position stability
            if (Math.abs(rollAngle) < 1.0) {
                rollAngle = 0;
            }

            // Update current angle directly (already heavily filtered)
            currentRollAngle = rollAngle;

            // Update debug display
            const debugElement = document.getElementById('rollDebug');
            if (debugElement) {
                const totalAccel = Math.sqrt(x*x + y*y + z*z);
                debugElement.textContent = `Motion: ${motionEnabled ? 'ON' : 'OFF'} | Total: ${totalAccel.toFixed(1)} | Roll: ${currentRollAngle.toFixed(1)}¬∞ | gX: ${gx.toFixed(2)}`;
            }
        }

        function updateRollDisplay(rollAngle) {
            // Display the already-filtered roll angle
            const displayAngle = currentRollAngle;

            // Update G-force display
            document.getElementById('lateralGForce').textContent = Math.abs(currentLateralG).toFixed(1);

            // Update artificial horizon
            const horizonLine = document.getElementById('horizonLine');
            if (horizonLine) {
                // Rotate the horizon line opposite to the roll angle
                // (aircraft symbol stays fixed, horizon rotates)
                horizonLine.setAttribute('transform', `rotate(${-displayAngle})`);
            }

            // Color coding based on G-force intensity
            const gForceElement = document.getElementById('lateralGForce');
            const absG = Math.abs(currentLateralG);

            if (absG < 0.3) {
                gForceElement.style.color = '#00ff00'; // Green - gentle cornering
            } else if (absG < 0.6) {
                gForceElement.style.color = '#ffff00'; // Yellow - moderate cornering
            } else if (absG < 1.0) {
                gForceElement.style.color = '#ff8800'; // Orange - aggressive cornering
            } else {
                gForceElement.style.color = '#ff0000'; // Red - extreme cornering
            }
        }

        function updateLateralGDisplay(lateralG) {
            // Smooth the G-force reading to reduce jitter
            const smoothedG = currentLateralG * 0.85 + lateralG * 0.15;
            currentLateralG = smoothedG;

            // Update display with 1 decimal precision
            document.getElementById('lateralGForce').textContent = Math.abs(smoothedG).toFixed(1);

            // Color coding based on G-force intensity (using absolute value)
            const gForceElement = document.getElementById('lateralGForce');
            const absG = Math.abs(smoothedG);

            if (absG < 0.3) {
                gForceElement.style.color = '#00ff00'; // Green - gentle cornering
            } else if (absG < 0.6) {
                gForceElement.style.color = '#ffff00'; // Yellow - moderate cornering
            } else if (absG < 1.0) {
                gForceElement.style.color = '#ff8800'; // Orange - aggressive cornering
            } else {
                gForceElement.style.color = '#ff0000'; // Red - extreme cornering
            }
        }

        function stopMotionDetection() {
            motionEnabled = false;
            if (motionAnimationId) {
                clearTimeout(motionAnimationId);
                motionAnimationId = null;
            }

            // Reset all display elements
            document.getElementById('accelMagnitude').textContent = '0.0';
            document.getElementById('accelXValue').textContent = '0.0';
            document.getElementById('accelYValue').textContent = '0.0';
            document.getElementById('accelZValue').textContent = '0.0';

            // Reset main vector
            const arrow = document.getElementById('accelArrow');
            arrow.setAttribute('x2', '0');
            arrow.setAttribute('y2', '0');
            arrow.setAttribute('stroke', '#ffff00');
            arrow.setAttribute('stroke-width', '3');
            arrow.style.filter = 'none';

            // Reset component vectors
            document.getElementById('accelX').setAttribute('x2', '0');
            document.getElementById('accelX').setAttribute('y2', '0');
            document.getElementById('accelY').setAttribute('x2', '0');
            document.getElementById('accelY').setAttribute('y2', '0');
            document.getElementById('accelZ').setAttribute('x2', '0');
            document.getElementById('accelZ').setAttribute('y2', '0');

            // Reset roll display
            currentRollAngle = 0;
            smoothedAccel = { x: 0, y: 0, z: 0 }; // Reset gravity filter
            const horizonLine = document.getElementById('horizonLine');
            if (horizonLine) {
                horizonLine.setAttribute('transform', 'rotate(0)');
            }

            // Reset lateral G-force display
            currentLateralG = 0;
        }

        // Turn Safety Calculation Functions
        function calculateSafeTurningRadius(speedMph, maxLateralG = null) {
            // Convert speed from mph to m/s
            const speedMs = speedMph * 0.44704;

            // Use physics-based safe lateral G limit if not provided
            if (!maxLateralG) {
                const { roadSurface, tireCondition, riderExperience, safetyMargin } = turnSafetySettings;
                maxLateralG = (roadSurface * tireCondition * riderExperience) / safetyMargin;
            }

            // Physics: radius = v¬≤ / (lateral_g √ó gravity)
            const gravity = 9.81; // m/s¬≤
            const radiusMeters = (speedMs * speedMs) / (maxLateralG * gravity);

            // Convert to feet for display
            const radiusFeet = radiusMeters * 3.28084;

            return {
                meters: radiusMeters,
                feet: radiusFeet,
                maxLateralG: maxLateralG
            };
        }

        function calculateMaxSafeSpeed(radiusFeet, maxLateralG = null) {
            // Convert radius to meters
            const radiusMeters = radiusFeet / 3.28084;

            // Use physics-based safe lateral G limit if not provided
            if (!maxLateralG) {
                const { roadSurface, tireCondition, riderExperience, safetyMargin } = turnSafetySettings;
                maxLateralG = (roadSurface * tireCondition * riderExperience) / safetyMargin;
            }

            // Physics: v = ‚àö(lateral_g √ó gravity √ó radius)
            const gravity = 9.81; // m/s¬≤
            const speedMs = Math.sqrt(maxLateralG * gravity * radiusMeters);

            // Convert to mph
            const speedMph = speedMs / 0.44704;

            return speedMph;
        }

        function getTurnSafetyZone(currentLateralG, currentLeanAngle) {
            // Progressive safety zones based on lateral G and lean angle
            const leanAngleAbs = Math.abs(currentLeanAngle);

            // Define zone thresholds
            if (currentLateralG < 0.5 && leanAngleAbs < 26) {
                return { zone: 'SAFE', color: '#00ff00' };
            } else if (currentLateralG < 0.7 && leanAngleAbs < 35) {
                return { zone: 'CAUTION', color: '#ffff00' };
            } else if (currentLateralG < 0.9 && leanAngleAbs < 42) {
                return { zone: 'WARNING', color: '#ff8800' };
            } else {
                return { zone: 'DANGER', color: '#ff0000' };
            }
        }

        function updateTurnSafetyDisplay() {
            const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;
            const currentLateralG = Math.abs(parseFloat(document.getElementById('lateralGForce').textContent) || 0);

            // Get current lean angle from the roll calculation
            const rollAngle = Math.abs(currentRollAngle || 0);

            if (currentSpeed > 5) { // Only calculate for meaningful speeds
                // Calculate safe turning radius at current speed
                const safeRadius = calculateSafeTurningRadius(currentSpeed);

                // Calculate maximum safe speed for a tight turn (50ft radius - city intersection)
                const maxSafeSpeedTight = calculateMaxSafeSpeed(50);

                // Get safety zone assessment
                const safetyZone = getTurnSafetyZone(currentLateralG, rollAngle);

                // Update display
                document.getElementById('safeRadius').textContent = Math.round(safeRadius.feet);
                document.getElementById('maxSafeSpeed').textContent = Math.round(maxSafeSpeedTight);
                document.getElementById('turnSafetyZone').textContent = safetyZone.zone;
                document.getElementById('turnSafetyZone').style.color = safetyZone.color;
            } else {
                // Reset display when not moving
                document.getElementById('safeRadius').textContent = '--';
                document.getElementById('maxSafeSpeed').textContent = '--';
                document.getElementById('turnSafetyZone').textContent = 'SAFE';
                document.getElementById('turnSafetyZone').style.color = '#00ff00';
            }
        }

        // Fuel Injection Estimation Functions
        function estimateThrottleLoad(yAcceleration, rpm, speed) {
            // Normalize Y-axis acceleration to estimate throttle position
            const accel = Math.max(0, yAcceleration); // Only consider forward acceleration
            const { accelThresholds } = FUEL_INJECTION_MODEL;

            // Base load estimation from acceleration
            let loadPercent = 0;
            if (accel < accelThresholds.idle) {
                loadPercent = 0.05 + (accel / accelThresholds.idle) * 0.15; // 5-20% for idle/cruise
            } else if (accel < accelThresholds.light) {
                loadPercent = 0.20 + ((accel - accelThresholds.idle) / (accelThresholds.light - accelThresholds.idle)) * 0.25; // 20-45%
            } else if (accel < accelThresholds.moderate) {
                loadPercent = 0.45 + ((accel - accelThresholds.light) / (accelThresholds.moderate - accelThresholds.light)) * 0.30; // 45-75%
            } else {
                loadPercent = 0.75 + Math.min(0.25, ((accel - accelThresholds.moderate) / (accelThresholds.heavy - accelThresholds.moderate)) * 0.25); // 75-100%
            }

            // Adjust for RPM (higher RPM = more airflow potential)
            const rpmFactor = rpm > 2000 ? Math.min(1.2, rpm / 4000) : 0.8;
            loadPercent *= rpmFactor;

            // Speed-based adjustment (highway vs city)
            if (speed > 45) {
                loadPercent *= 0.9; // Highway cruising is more efficient
            }

            return Math.min(1.0, Math.max(0.05, loadPercent));
        }

        function getLoadCategory(throttleLoad) {
            if (throttleLoad < 0.15) return 'idle';
            if (throttleLoad < 0.35) return 'cruise';
            if (throttleLoad < 0.60) return 'light';
            if (throttleLoad < 0.85) return 'moderate';
            return 'heavy';
        }

        function interpolateVolumetricEfficiency(rpm) {
            const { veTable } = FUEL_INJECTION_MODEL;
            const rpmPoints = Object.keys(veTable).map(Number).sort((a, b) => a - b);

            // Handle edge cases
            if (rpm <= rpmPoints[0]) return veTable[rpmPoints[0]];
            if (rpm >= rpmPoints[rpmPoints.length - 1]) return veTable[rpmPoints[rpmPoints.length - 1]];

            // Linear interpolation between points
            for (let i = 0; i < rpmPoints.length - 1; i++) {
                const lowerRPM = rpmPoints[i];
                const upperRPM = rpmPoints[i + 1];

                if (rpm >= lowerRPM && rpm <= upperRPM) {
                    const ratio = (rpm - lowerRPM) / (upperRPM - lowerRPM);
                    return veTable[lowerRPM] + ratio * (veTable[upperRPM] - veTable[lowerRPM]);
                }
            }

            return 0.8; // Fallback
        }

        function calculateFuelInjectionPerStroke(rpm, yAcceleration, speed) {
            if (rpm < 500) return 0; // Engine not running

            const { baseFuelPerStroke, afrTable } = FUEL_INJECTION_MODEL;

            // Estimate throttle load from Y-axis acceleration
            const throttleLoad = estimateThrottleLoad(yAcceleration, rpm, speed);
            const loadCategory = getLoadCategory(throttleLoad);

            // Get volumetric efficiency for current RPM
            const volumetricEfficiency = interpolateVolumetricEfficiency(rpm);

            // Get air-fuel ratio for current load
            const targetAFR = afrTable[loadCategory];

            // Calculate fuel per stroke
            // Base formula: fuel = (base_fuel √ó VE √ó load √ó AFR_correction)
            const veCorrection = volumetricEfficiency / 0.8; // Normalize to base VE
            const loadCorrection = 0.3 + (throttleLoad * 0.7); // Scale from 30% to 100%
            const afrCorrection = 14.7 / targetAFR; // Richer = more fuel

            const fuelPerStroke = baseFuelPerStroke * veCorrection * loadCorrection * afrCorrection;

            return {
                fuelPerStroke: Math.max(0.5, Math.min(4.5, fuelPerStroke)), // Clamp to realistic range
                throttleLoad: throttleLoad,
                volumetricEfficiency: volumetricEfficiency,
                targetAFR: targetAFR,
                loadCategory: loadCategory
            };
        }

        function updateFuelInjectionEstimate() {
            const rpm = currentRPM || 0;
            const speed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;

            // Get Y-axis acceleration (forward/backward)
            const yAcceleration = currentAccel.y || 0;

            if (rpm > 500) { // Only calculate when engine is running
                const injection = calculateFuelInjectionPerStroke(rpm, yAcceleration, speed);

                // Calculate rates
                const strokesPerSecond = (rpm / 60) * (FUEL_INJECTION_MODEL.cylinders / 2); // 4-stroke engine
                const fuelPerSecond = injection.fuelPerStroke * strokesPerSecond;
                const fuelPerMinute = fuelPerSecond * 60;

                // Update current state
                currentFuelInjection = {
                    perStroke: injection.fuelPerStroke,
                    perSecond: fuelPerSecond,
                    perMinute: fuelPerMinute,
                    throttleLoad: injection.throttleLoad,
                    estimatedAFR: injection.targetAFR,
                    loadCategory: injection.loadCategory,
                    volumetricEfficiency: injection.volumetricEfficiency
                };

                // Update display
                updateFuelInjectionDisplay();
            } else {
                // Engine not running
                currentFuelInjection = {
                    perStroke: 0,
                    perSecond: 0,
                    perMinute: 0,
                    throttleLoad: 0,
                    estimatedAFR: 14.7,
                    loadCategory: 'idle',
                    volumetricEfficiency: 0
                };
                updateFuelInjectionDisplay();
            }
        }

        function updateFuelInjectionDisplay() {
            // Update existing fuel displays with injection data
            if (currentFuelInjection.perStroke > 0) {
                const injectionElement = document.getElementById('fuelInjectionRate');
                if (injectionElement) {
                    injectionElement.textContent = `${currentFuelInjection.perStroke.toFixed(2)}cc/stroke`;
                }

                const loadElement = document.getElementById('throttleLoad');
                if (loadElement) {
                    loadElement.textContent = `${(currentFuelInjection.throttleLoad * 100).toFixed(0)}%`;
                }

                const afrElement = document.getElementById('estimatedAFR');
                if (afrElement) {
                    afrElement.textContent = `${currentFuelInjection.estimatedAFR.toFixed(1)}:1`;
                }
            }
        }

        // GPS Turn Detection Functions
        function calculateBearing(lat1, lon1, lat2, lon2) {
            // Calculate bearing between two GPS points
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const lat1Rad = lat1 * Math.PI / 180;
            const lat2Rad = lat2 * Math.PI / 180;

            const y = Math.sin(dLon) * Math.cos(lat2Rad);
            const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) -
                      Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon);

            let bearing = Math.atan2(y, x) * 180 / Math.PI;
            return (bearing + 360) % 360; // Normalize to 0-360 degrees
        }

        function normalizeBearingDifference(bearing1, bearing2) {
            // Calculate the smallest angle difference between two bearings
            let diff = bearing2 - bearing1;
            if (diff > 180) diff -= 360;
            if (diff < -180) diff += 360;
            return diff;
        }

        function updateGPSTrackHistory(position, speed, timestamp) {
            const currentSpeed = speed || parseFloat(document.getElementById('currentSpeed').textContent) || 0;

            // Only track when moving at meaningful speeds
            if (currentSpeed < TURN_DETECTION.MIN_SPEED) {
                return;
            }

            // Add current position to history
            gpsTrackHistory.push({
                lat: position.lat,
                lon: position.lon,
                speed: currentSpeed,
                timestamp: timestamp,
                accuracy: position.accuracy
            });

            // Maintain history window
            const cutoffTime = timestamp - (TURN_DETECTION.HISTORY_SECONDS * 1000);
            gpsTrackHistory = gpsTrackHistory.filter(point => point.timestamp > cutoffTime);

            // Calculate bearing if we have enough history
            if (gpsTrackHistory.length >= TURN_DETECTION.SMOOTH_WINDOW) {
                const recentPoints = gpsTrackHistory.slice(-TURN_DETECTION.SMOOTH_WINDOW);
                const startPoint = recentPoints[0];
                const endPoint = recentPoints[recentPoints.length - 1];

                // Only calculate bearing for meaningful distance (avoid GPS noise)
                const distance = calculateDistance(startPoint, endPoint);
                if (distance > 0.001) { // More than ~5 feet
                    const currentBearing = calculateBearing(
                        startPoint.lat, startPoint.lon,
                        endPoint.lat, endPoint.lon
                    );

                    // Update bearing history
                    bearingHistory.push({
                        bearing: currentBearing,
                        timestamp: timestamp,
                        speed: currentSpeed
                    });

                    // Maintain bearing history
                    bearingHistory = bearingHistory.filter(b => b.timestamp > cutoffTime);

                    lastGPSBearing = currentBearing;

                    // Detect turns
                    detectGPSTurn(timestamp, currentSpeed);
                }
            }
        }

        function detectGPSTurn(timestamp, currentSpeed) {
            if (bearingHistory.length < 2) return;

            // Get bearing change over last few seconds
            const recentWindow = bearingHistory.filter(b =>
                b.timestamp > timestamp - 3000 // Last 3 seconds
            );

            if (recentWindow.length < 2) return;

            const startBearing = recentWindow[0].bearing;
            const endBearing = recentWindow[recentWindow.length - 1].bearing;
            const bearingChange = Math.abs(normalizeBearingDifference(startBearing, endBearing));

            // Check for turn initiation
            if (!currentTurn && bearingChange > TURN_DETECTION.BEARING_CHANGE_THRESHOLD) {
                currentTurn = {
                    startTime: timestamp,
                    startBearing: startBearing,
                    direction: normalizeBearingDifference(startBearing, endBearing) > 0 ? 'right' : 'left',
                    maxBearingChange: bearingChange,
                    entrySpeed: currentSpeed,
                    peakLateralG: 0,
                    peakLeanAngle: 0
                };

                debugLog(`üîÑ Turn initiated: ${currentTurn.direction}, ${bearingChange.toFixed(1)}¬∞ change at ${currentSpeed} mph`);
                evaluateTurnSafety();
            }

            // Update active turn
            if (currentTurn) {
                const totalChange = Math.abs(normalizeBearingDifference(currentTurn.startBearing, endBearing));
                currentTurn.maxBearingChange = Math.max(currentTurn.maxBearingChange, totalChange);

                // Track peak values during turn
                const currentLateralG = Math.abs(parseFloat(document.getElementById('lateralGForce').textContent) || 0);
                const currentLeanAngle = Math.abs(currentRollAngle || 0);
                currentTurn.peakLateralG = Math.max(currentTurn.peakLateralG, currentLateralG);
                currentTurn.peakLeanAngle = Math.max(currentTurn.peakLeanAngle, currentLeanAngle);

                // Check for turn completion (bearing stabilizes)
                const recentChangeWindow = bearingHistory.filter(b =>
                    b.timestamp > timestamp - 1500 // Last 1.5 seconds
                );

                if (recentChangeWindow.length >= 2) {
                    const recentStart = recentChangeWindow[0].bearing;
                    const recentEnd = recentChangeWindow[recentChangeWindow.length - 1].bearing;
                    const recentChange = Math.abs(normalizeBearingDifference(recentStart, recentEnd));

                    if (recentChange < TURN_DETECTION.TURN_COMPLETION_THRESHOLD) {
                        completeTurn(timestamp);
                    }
                }
            }
        }

        function evaluateTurnSafety() {
            if (!currentTurn) return;

            const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;
            const currentLateralG = Math.abs(parseFloat(document.getElementById('lateralGForce').textContent) || 0);
            const currentLeanAngle = Math.abs(currentRollAngle || 0);

            // Estimate turn radius based on speed and bearing change rate
            const bearingChangeRate = currentTurn.maxBearingChange / ((Date.now() - currentTurn.startTime) / 1000);
            const estimatedRadius = (currentSpeed * 0.44704) / (bearingChangeRate * Math.PI / 180); // rough approximation

            // Check various warning conditions
            const warnings = [];

            // Speed warning for current turn radius
            if (estimatedRadius > 0 && estimatedRadius < 500) { // Only for reasonable radius estimates
                const maxSafeSpeed = calculateMaxSafeSpeed(estimatedRadius * 3.28084); // Convert to feet
                if (currentSpeed > maxSafeSpeed * 1.1) { // 10% buffer
                    warnings.push(`SPEED: ${currentSpeed} mph too fast for ${Math.round(estimatedRadius * 3.28084)}ft radius`);
                }
            }

            // Lean angle warnings
            if (currentLeanAngle > 35) {
                warnings.push(`LEAN: ${currentLeanAngle.toFixed(1)}¬∞ approaching limits`);
            }

            // Lateral G warnings
            if (currentLateralG > 0.7) {
                warnings.push(`G-FORCE: ${currentLateralG.toFixed(2)}g high cornering load`);
            }

            // Progressive lean angle increase
            if (currentTurn.peakLeanAngle > 0 && currentLeanAngle > currentTurn.peakLeanAngle + 5) {
                warnings.push(`LEAN INCREASE: Adding ${(currentLeanAngle - currentTurn.peakLeanAngle).toFixed(1)}¬∞ mid-turn`);
            }

            // Update warning state
            if (warnings.length > 0 && !turnWarningActive) {
                turnWarningActive = true;
                debugLog(`‚ö†Ô∏è Turn Warning: ${warnings.join(' | ')}`);
                displayTurnWarning(warnings);
            } else if (warnings.length === 0 && turnWarningActive) {
                turnWarningActive = false;
                clearTurnWarning();
            }

            // Always update turn indicator during active turns
            updateTurnIndicator();
        }

        function completeTurn(timestamp) {
            if (!currentTurn) return;

            const duration = (timestamp - currentTurn.startTime) / 1000;
            debugLog(`‚úÖ Turn completed: ${currentTurn.direction}, ` +
                       `${currentTurn.maxBearingChange.toFixed(1)}¬∞ total, ` +
                       `${duration.toFixed(1)}s, ` +
                       `peak lean: ${currentTurn.peakLeanAngle.toFixed(1)}¬∞, ` +
                       `peak G: ${currentTurn.peakLateralG.toFixed(2)}g`);

            // Log turn data for analytics
            logTurnData(currentTurn, duration);

            // Reset turn state
            currentTurn = null;
            turnWarningActive = false;
            clearTurnWarning();
        }

        function logTurnData(turn, duration) {
            // Add turn data to existing data logging if active
            if (isDataLogging && turn) {
                const turnLogEntry = {
                    timestamp: Date.now(),
                    type: 'turn_completed',
                    direction: turn.direction,
                    maxBearingChange: turn.maxBearingChange,
                    duration: duration,
                    entrySpeed: turn.entrySpeed,
                    peakLateralG: turn.peakLateralG,
                    peakLeanAngle: turn.peakLeanAngle
                };

                // This would integrate with existing logging system
                debugLog(`üìä Turn logged: ${JSON.stringify(turnLogEntry)}`);
            }
        }

        function displayTurnWarning(warnings) {
            // Update the turn safety zone display with warning color
            const zoneElement = document.getElementById('turnSafetyZone');
            if (zoneElement) {
                zoneElement.textContent = 'WARNING';
                zoneElement.style.color = '#ff8800';
                zoneElement.style.fontWeight = 'bold';
            }

            // Update turn indicator
            updateTurnIndicator();

            // Could add audio warning here if needed
            // playTurnWarningSound();
        }

        function clearTurnWarning() {
            // Reset turn warning display
            updateTurnSafetyDisplay(); // This will recalculate the normal safety zone
            updateTurnIndicator();
        }

        function updateTurnIndicator() {
            const turnIndicator = document.getElementById('turnIndicator');
            if (!turnIndicator) return;

            if (currentTurn) {
                const direction = currentTurn.direction;
                const bearingChange = currentTurn.maxBearingChange.toFixed(0);
                const arrow = direction === 'left' ? '‚Üê LEFT' : 'RIGHT ‚Üí';
                const color = turnWarningActive ? '#ff8800' : '#00ff00';

                turnIndicator.textContent = `${arrow} ${bearingChange}¬∞`;
                turnIndicator.style.color = color;
                turnIndicator.style.fontWeight = 'bold';
            } else {
                turnIndicator.textContent = '--';
                turnIndicator.style.color = '#888';
                turnIndicator.style.fontWeight = 'normal';
            }
        }

        // Daylight Calculation Functions
        function calculateSunset(latitude, longitude, date = new Date()) {
            // Simplified sunset calculation using the sunrise equation
            // This is an approximation that's accurate enough for motorcycle riding purposes

            const dayOfYear = getDayOfYear(date);
            const latRad = latitude * Math.PI / 180;

            // Solar declination angle
            const declination = 23.45 * Math.sin((360 * (284 + dayOfYear) / 365) * Math.PI / 180);
            const declinationRad = declination * Math.PI / 180;

            // Hour angle for sunset (when sun is at horizon)
            const hourAngle = Math.acos(-Math.tan(latRad) * Math.tan(declinationRad));
            const hourAngleDeg = hourAngle * 180 / Math.PI;

            // Solar noon occurs at 12:00 + equation of time + longitude correction
            const equationOfTime = 4 * (longitude - 15 * Math.round(longitude / 15)); // Rough approximation
            const solarNoon = 12 + equationOfTime / 60;

            // Sunset time
            const sunsetHour = solarNoon + hourAngleDeg / 15;

            // Convert to local time
            const sunsetDate = new Date(date);
            sunsetDate.setHours(Math.floor(sunsetHour));
            sunsetDate.setMinutes((sunsetHour % 1) * 60);
            sunsetDate.setSeconds(0);
            sunsetDate.setMilliseconds(0);

            return sunsetDate;
        }

        function getDayOfYear(date) {
            const start = new Date(date.getFullYear(), 0, 0);
            const diff = date - start;
            const oneDay = 1000 * 60 * 60 * 24;
            return Math.floor(diff / oneDay);
        }

        function updateDaylightDisplay() {
            // Only update if we have GPS coordinates
            if (!lastPosition) {
                document.getElementById('remainingDaylight').textContent = '--:--';
                return;
            }

            const now = new Date();

            // Recalculate sunset if it's a new day or first calculation
            if (!lastSunsetCalculation ||
                now.toDateString() !== lastSunsetCalculation.toDateString()) {

                sunsetTime = calculateSunset(lastPosition.lat, lastPosition.lon, now);
                lastSunsetCalculation = new Date(now);
            }

            // Calculate remaining time until sunset
            const remainingMs = sunsetTime - now;

            if (remainingMs <= 0) {
                // Sun has already set
                document.getElementById('remainingDaylight').textContent = '--:--';
                document.getElementById('remainingDaylight').style.color = '#888888';
            } else {
                // Calculate hours and minutes remaining
                const remainingHours = Math.floor(remainingMs / (1000 * 60 * 60));
                const remainingMinutes = Math.floor((remainingMs % (1000 * 60 * 60)) / (1000 * 60));

                // Format as HH:MM
                const timeString = `${remainingHours}:${remainingMinutes.toString().padStart(2, '0')}`;
                document.getElementById('remainingDaylight').textContent = timeString;

                // Color coding based on remaining daylight
                const daylightElement = document.getElementById('remainingDaylight');
                if (remainingHours >= 3) {
                    daylightElement.style.color = '#00ff00'; // Green - plenty of daylight
                } else if (remainingHours >= 1) {
                    daylightElement.style.color = '#ffff00'; // Yellow - getting late
                } else {
                    daylightElement.style.color = '#ff8800'; // Orange - sunset approaching
                }
            }
        }

        function startDaylightTracking() {
            // Update daylight display every minute
            updateDaylightDisplay();
            if (daylightUpdateInterval) clearInterval(daylightUpdateInterval);
            daylightUpdateInterval = setInterval(updateDaylightDisplay, 60000); // Update every minute
        }

        function stopDaylightTracking() {
            if (daylightUpdateInterval) {
                clearInterval(daylightUpdateInterval);
                daylightUpdateInterval = null;
            }
            document.getElementById('remainingDaylight').textContent = '--:--';
            document.getElementById('remainingDaylight').style.color = '#ffffff';
        }

        // Data Logging System Functions
        function toggleDataLogging() {
            const logBtn = document.getElementById('dataLogBtn');

            if (!isLogging) {
                startDataLogging();
                logBtn.textContent = 'Stop Data Log';
                logBtn.style.background = 'rgba(255, 100, 100, 0.7)';
            } else {
                stopDataLogging();
                logBtn.textContent = 'Start Data Log';
                logBtn.style.background = '';
            }
        }

        function toggleCalibration() {
            const content = document.getElementById('calibrationContent');
            const toggle = document.getElementById('calibrationToggle');

            if (content.style.display === 'none') {
                content.style.display = 'block';
                toggle.textContent = '‚ñ≤';
            } else {
                content.style.display = 'none';
                toggle.textContent = '‚ñº';
            }
        }

        function startDataLogging() {
            isLogging = true;
            logStartTime = Date.now();
            dataLog = [];

            document.getElementById('dataLogStatus').style.display = 'block';
            updateLogStatus();

            // Start periodic log status updates
            if (window.logStatusInterval) clearInterval(window.logStatusInterval);
            window.logStatusInterval = setInterval(updateLogStatus, 2000);

            // Start 10Hz logging
            startHighFrequencyLogging();
        }

        function stopDataLogging() {
            isLogging = false;

            if (window.logStatusInterval) {
                clearInterval(window.logStatusInterval);
                window.logStatusInterval = null;
            }

            // Stop 10Hz logging timer
            if (loggingTimer) {
                clearInterval(loggingTimer);
                loggingTimer = null;
            }

            // Final status update
            updateLogStatus();
        }

        function startHighFrequencyLogging() {
            // Log data at 10Hz (every 100ms) when logging is enabled
            loggingTimer = setInterval(() => {
                if (isLogging && lastPosition) {
                    // Get current values for logging
                    const currentSpeed = parseFloat(document.getElementById('currentSpeed').textContent) || 0;
                    const currentMPGValue = parseFloat(document.getElementById('currentMPG').textContent) || 0;

                    // Use minimal distance since this is frequent logging
                    const distance = 0; // High frequency logging doesn't track distance
                    const timeMinutes = 0.1 / 60; // 100ms in minutes

                    logDataPoint(currentSpeed, currentMPGValue, distance, timeMinutes);
                }
            }, 100); // 100ms = 10Hz
        }

        function logDataPoint(speed, mpg, distance, timeMinutes) {
            // Prevent memory overflow
            if (dataLog.length >= maxLogEntries) {
                dataLog.shift(); // Remove oldest entry
            }

            const timestamp = Date.now();
            const logEntry = {
                timestamp: timestamp,
                relativeTime: logStartTime ? timestamp - logStartTime : 0,
                speed: Math.round(speed * 100) / 100,
                rpm: currentRPM || 0,
                mpg: Math.round(mpg * 100) / 100,
                distance: Math.round(distance * 10000) / 10000,
                timeInterval: Math.round(timeMinutes * 1000) / 1000,
                fuelUsed: Math.round(fuelUsed * 1000) / 1000,
                tripDistance: Math.round(tripDistance * 100) / 100,
                fuelRemaining: Math.round((tankCapacity - fuelUsed) * 100) / 100,
                estimatedRange: Math.round((tankCapacity - fuelUsed) * mpg),
                acceleration: {
                    x: Math.round(currentAccel.x * 100) / 100,
                    y: Math.round(currentAccel.y * 100) / 100,
                    z: Math.round(currentAccel.z * 100) / 100,
                    magnitude: Math.round(Math.sqrt(currentAccel.x*currentAccel.x + currentAccel.y*currentAccel.y + currentAccel.z*currentAccel.z) * 100) / 100
                },
                gyroscope: {
                    x: Math.round(currentGyro.x * 100) / 100,
                    y: Math.round(currentGyro.y * 100) / 100,
                    z: Math.round(currentGyro.z * 100) / 100
                },
                gps: lastPosition ? {
                    latitude: Math.round(lastPosition.lat * 1000000) / 1000000,
                    longitude: Math.round(lastPosition.lon * 1000000) / 1000000,
                    accuracy: Math.round(lastPosition.accuracy * 10) / 10
                } : null,
                audioHarmonics: {
                    dominant: {
                        frequency: Math.round(currentHarmonics.dominant.frequency * 10) / 10,
                        amplitude: currentHarmonics.dominant.amplitude
                    },
                    second: {
                        frequency: Math.round(currentHarmonics.second.frequency * 10) / 10,
                        amplitude: currentHarmonics.second.amplitude
                    },
                    third: {
                        frequency: Math.round(currentHarmonics.third.frequency * 10) / 10,
                        amplitude: currentHarmonics.third.amplitude
                    },
                    fourth: {
                        frequency: Math.round(currentHarmonics.fourth.frequency * 10) / 10,
                        amplitude: currentHarmonics.fourth.amplitude
                    }
                },
                engineConfig: {
                    cylinders: calibration.engine.cylinders,
                    idleRPM: calibration.engine.idleRPM,
                    redlineRPM: calibration.engine.redlineRPM,
                    enableRPM: calibration.engine.enableRPM
                },
                fuelInjection: {
                    perStroke: Math.round(currentFuelInjection.perStroke * 100) / 100,
                    perSecond: Math.round(currentFuelInjection.perSecond * 100) / 100,
                    perMinute: Math.round(currentFuelInjection.perMinute * 100) / 100,
                    throttleLoad: Math.round(currentFuelInjection.throttleLoad * 1000) / 1000,
                    estimatedAFR: Math.round(currentFuelInjection.estimatedAFR * 10) / 10,
                    loadCategory: currentFuelInjection.loadCategory,
                    volumetricEfficiency: Math.round(currentFuelInjection.volumetricEfficiency * 1000) / 1000
                },
                calibration: {
                    highway: calibration.highway,
                    local: calibration.local,
                    idle: calibration.idle
                }
            };

            dataLog.push(logEntry);
        }

        function updateLogStatus() {
            if (!isLogging && !dataLog.length) return;

            document.getElementById('logEntries').textContent = dataLog.length;

            // Calculate session duration
            const duration = logStartTime ? Date.now() - logStartTime : 0;
            const minutes = Math.floor(duration / 60000);
            const seconds = Math.floor((duration % 60000) / 1000);
            document.getElementById('logDuration').textContent = `${minutes}:${seconds.toString().padStart(2, '0')}`;

            // Calculate data rate (entries per minute)
            const dataRate = duration > 0 ? Math.round((dataLog.length / duration) * 60000 * 10) / 10 : 0;
            document.getElementById('dataRate').textContent = dataRate;

            // Estimate log size in KB
            const logSizeBytes = JSON.stringify(dataLog).length;
            const logSizeKB = Math.round(logSizeBytes / 1024 * 10) / 10;
            document.getElementById('logSize').textContent = logSizeKB;
        }

        function exportDataLog() {
            if (dataLog.length === 0) {
                alert('No data to export. Start logging first.');
                return;
            }

            // Create CSV export
            const csvData = generateCSV(dataLog);

            // Create and download CSV file
            const csvBlob = new Blob([csvData], {
                type: 'text/csv'
            });
            const csvUrl = URL.createObjectURL(csvBlob);
            const csvLink = document.createElement('a');
            csvLink.href = csvUrl;
            csvLink.download = `motorcycle-fuel-log-${new Date().toISOString().split('T')[0]}.csv`;
            csvLink.click();
            URL.revokeObjectURL(csvUrl);

            alert(`CSV data exported successfully!\n\nEntries: ${dataLog.length}\nFile downloaded.`);
        }

        function generateCSV(data) {
            if (data.length === 0) return '';

            // CSV headers - configuration/constant fields first, then computed values
            const headers = [
                // Configuration and engine settings (constant fields)
                'Engine_Cylinders', 'Engine_Idle_RPM', 'Engine_Redline_RPM', 'RPM_Detection_Enabled',
                'Highway_Speed_mph', 'Highway_MPG', 'Local_Speed_mph', 'Local_MPG', 'Idle_Consumption_galhr',

                // Timestamp and tracking data
                'Timestamp', 'ISO_DateTime', 'Relative_Time_ms', 'Time_Interval_min',

                // Raw sensor inputs
                'GPS_Latitude', 'GPS_Longitude', 'GPS_Accuracy_m',
                'Accel_X_ms2', 'Accel_Y_ms2', 'Accel_Z_ms2', 'Accel_Magnitude_ms2',
                'Gyro_X_degs', 'Gyro_Y_degs', 'Gyro_Z_degs',
                'Audio_Dominant_Freq_Hz', 'Audio_Dominant_Amplitude', 'Audio_2nd_Freq_Hz', 'Audio_2nd_Amplitude',
                'Audio_3rd_Freq_Hz', 'Audio_3rd_Amplitude', 'Audio_4th_Freq_Hz', 'Audio_4th_Amplitude',

                // Turn detection data
                'GPS_Bearing_deg', 'Turn_Active', 'Turn_Direction', 'Turn_Bearing_Change_deg',
                'Turn_Safety_Zone', 'Turn_Warning_Active',

                // Fuel injection estimation data
                'Fuel_Per_Stroke_cc', 'Fuel_Per_Second_cc', 'Fuel_Per_Minute_cc',
                'Throttle_Load_Percent', 'Estimated_AFR', 'Load_Category', 'Volumetric_Efficiency',

                // Computed values (derived from sensors and settings)
                'Speed_mph', 'RPM', 'Distance_miles', 'MPG', 'Fuel_Used_gal',
                'Trip_Distance_miles', 'Fuel_Remaining_gal', 'Estimated_Range_miles'
            ];

            let csv = headers.join(',') + '\n';

            // CSV data rows - reordered to match new header order
            data.forEach(entry => {
                const row = [
                    // Configuration and engine settings (constant fields)
                    entry.engineConfig.cylinders,
                    entry.engineConfig.idleRPM,
                    entry.engineConfig.redlineRPM,
                    entry.engineConfig.enableRPM,
                    entry.calibration.highway.speed,
                    entry.calibration.highway.mpg,
                    entry.calibration.local.speed,
                    entry.calibration.local.mpg,
                    entry.calibration.idle.gallonsPerHour,

                    // Timestamp and tracking data
                    entry.timestamp,
                    new Date(entry.timestamp).toISOString(),
                    entry.relativeTime,
                    entry.timeInterval,

                    // Raw sensor inputs
                    entry.gps ? entry.gps.latitude : '',
                    entry.gps ? entry.gps.longitude : '',
                    entry.gps ? entry.gps.accuracy : '',
                    entry.acceleration.x,
                    entry.acceleration.y,
                    entry.acceleration.z,
                    entry.acceleration.magnitude,
                    entry.gyroscope.x,
                    entry.gyroscope.y,
                    entry.gyroscope.z,
                    entry.audioHarmonics ? entry.audioHarmonics.dominant.frequency : '',
                    entry.audioHarmonics ? entry.audioHarmonics.dominant.amplitude : '',
                    entry.audioHarmonics ? entry.audioHarmonics.second.frequency : '',
                    entry.audioHarmonics ? entry.audioHarmonics.second.amplitude : '',
                    entry.audioHarmonics ? entry.audioHarmonics.third.frequency : '',
                    entry.audioHarmonics ? entry.audioHarmonics.third.amplitude : '',
                    entry.audioHarmonics ? entry.audioHarmonics.fourth.frequency : '',
                    entry.audioHarmonics ? entry.audioHarmonics.fourth.amplitude : '',

                    // Turn detection data
                    lastGPSBearing || '',
                    currentTurn ? 'YES' : 'NO',
                    currentTurn ? currentTurn.direction : '',
                    currentTurn ? currentTurn.maxBearingChange : '',
                    document.getElementById('turnSafetyZone') ? document.getElementById('turnSafetyZone').textContent : '',
                    turnWarningActive ? 'YES' : 'NO',

                    // Fuel injection estimation data
                    entry.fuelInjection ? entry.fuelInjection.perStroke : '',
                    entry.fuelInjection ? entry.fuelInjection.perSecond : '',
                    entry.fuelInjection ? entry.fuelInjection.perMinute : '',
                    entry.fuelInjection ? (entry.fuelInjection.throttleLoad * 100).toFixed(1) : '',
                    entry.fuelInjection ? entry.fuelInjection.estimatedAFR : '',
                    entry.fuelInjection ? entry.fuelInjection.loadCategory : '',
                    entry.fuelInjection ? entry.fuelInjection.volumetricEfficiency : '',

                    // Computed values (derived from sensors and settings)
                    entry.speed,
                    entry.rpm,
                    entry.distance,
                    entry.mpg,
                    entry.fuelUsed,
                    entry.tripDistance,
                    entry.fuelRemaining,
                    entry.estimatedRange
                ];
                csv += row.join(',') + '\n';
            });

            return csv;
        }

        function clearDataLog() {
            if (dataLog.length === 0) {
                alert('No data to clear.');
                return;
            }

            if (confirm(`Clear ${dataLog.length} log entries?\n\nThis cannot be undone.`)) {
                dataLog = [];
                logStartTime = null;

                if (isLogging) {
                    stopDataLogging();
                    document.getElementById('dataLogBtn').textContent = 'Start Data Log';
                    document.getElementById('dataLogBtn').style.background = '';
                }

                document.getElementById('dataLogStatus').style.display = 'none';
                alert('Data log cleared successfully.');
            }
        }
    </script>
</body>
</html>
